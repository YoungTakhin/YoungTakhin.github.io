[{"title":"Spring框架入门4. Spring依赖注入","date":"2019-12-23T04:55:41.000Z","date_formatted":{"ll":"2019年12月23日","L":"2019/12/23","MM-DD":"12-23"},"updated":"2019-12-23T07:10:18.998Z","content":"Spring框架入门4. Spring依赖注入依赖注入依赖注入（Dependency Injection，缩写为DI）是 Spring 框架核心 IoC 的具体实现。我们的程序在编写时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。\nIoC 解耦只是降低他们的依赖关系，但不会消除。\n在某个类中需要用到其他类的对象，由 Spring 为我们提供，我们只需要在配置文件中说明，这种依赖关系的维护就称之为依赖注入。\n例如：我们的业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。\n依赖注入的方式通过构造方法注入在 bean 标签中使用 constructor-arg 标签。\nconstructor-arg 标签有五个属性：\n\ntype：用于指定参数在构造方法中的数据类型，该数据类型也是要注入数据的数据类型；\nindex：用于指定参数在构造方法参数列表的索引位置，索引从0开始；\nname：用于指定参数在构造函数中的名称，此属性更常用；\nvalue：用于提供基本数据类型和 String 类型的赋值；\nref：用于指定其他 bean 数据类型的赋值，它指的是在 Spring IoC 核心容器中出现过的 bean 对象。 \n\n\n在实体类 Account 中添加构造方法\nAccount.java12345678910111213141516171819202122232425package com.ydx.domain;import java.util.Date;public class Account &#123;    private String name;    private int age;    private Date birthday;        public Account(String name, int age, Date birthday) &#123;        this.name = name;        this.age = age;        this.birthday = birthday;    &#125;        @Override    public String toString() &#123;        return \"Account&#123;\" +               \"name='\" + name + '\\'' +               \", age=\" + age +               \", birthday=\" + birthday +               '&#125;';    &#125;&#125;  \n\n配置文件\napplicationContext.xml123456789&lt;bean id=\"account\" class=\"com.ydx.domain.Account\" &gt;    &lt;constructor-arg index=\"0\" value=\"ydx\" /&gt;    &lt;constructor-arg type=\"int\" value=\"23\" /&gt;    &lt;constructor-arg name=\"birthday\" ref=\"now\" /&gt;&lt;/bean&gt;  &lt;!-- 配置一个日期对象 --&gt;&lt;bean id=\"now\" class=\"java.util.Date\" /&gt;  \n\n测试类\nBaseTest.java12345678910111213141516171819package com.ydx;import com.ydx.domain.Account;import org.springframework.context.support.ClassPathXmlApplicationContext;public class BaseTest &#123;    /**     * 获取Spring的IoC核心容器，并根据id获取对象     * @param args     */    public static void main(String[] args) &#123;        //获取核心容器对象        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");        //根据id获取bean对象        Account account = ac.getBean(\"account\", Account.class);        System.out.println(account.toString());    &#125;&#125;  \n\n运行结果：\n1Account&#123;name='ydx', age=23, birthday=Mon Dec 23 14:21:03 CST 2019&#125;\n\n\n\n通过set方法注入在 bean 标签中使用 property 标签。\nproperty 标签有三个属性：\n\nname：用于指定参数在构造函数中的名称；\nvalue：用于提供基本数据类型和 String 类型的赋值；\nref：用于指定其他 bean 数据类型的赋值，它指的是在 Spring IoC 核心容器中出现过的 bean 对象。\n\n\n在实体类 Account 中为属性添加 set 方法\nAccount.java12345678910111213141516171819202122232425262728293031package com.ydx.domain;import java.util.Date;public class Account &#123;    private String name;    private int age;    private Date birthday;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    @Override    public String toString() &#123;        return \"Account&#123;\" +                \"name='\" + name + '\\'' +                \", age=\" + age +                \", birthday=\" + birthday +                '&#125;';    &#125;&#125;  \n\n配置文件\napplicationContext.xml123456789&lt;bean id=\"account\" class=\"com.ydx.domain.Account\" &gt;    &lt;property name=\"name\" value=\"ydx\" /&gt;    &lt;property name=\"age\" value=\"23\" /&gt;    &lt;property name=\"birthday\" ref=\"now\" /&gt;&lt;/bean&gt;&lt;!-- 配置一个日期对象 --&gt;&lt;bean id=\"now\" class=\"java.util.Date\" /&gt;  \n\n测试类\nBaseTest.java12345678910111213141516171819package com.ydx;import com.ydx.domain.Account;import org.springframework.context.support.ClassPathXmlApplicationContext;public class BaseTest &#123;    /**     * 获取Spring的IoC核心容器，并根据id获取对象     * @param args     */    public static void main(String[] args) &#123;        //获取核心容器对象        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");        //根据id获取bean对象        Account account = ac.getBean(\"account\", Account.class);        System.out.println(account.toString());    &#125;&#125;  \n\n运行结果：\n1Account&#123;name='ydx', age=23, birthday=Mon Dec 23 14:21:03 CST 2019&#125;\n\n\n\n复杂/集合类型的注入以下示例采用 set 注入方式\n\n编写 JavaCollection 类\nJavaCollection.java1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ydx.domain;import java.util.*;public class JavaCollection &#123;    private String[] myStr;    private List&lt;String&gt; myList;    private Set&lt;String&gt; mySet;    private Map&lt;String, String&gt; myMap;    private Properties myProp;    public void setMyStr(String[] myStr) &#123;        this.myStr = myStr;    &#125;    public void setMyList(List&lt;String&gt; myList) &#123;        this.myList = myList;    &#125;    public void setMySet(Set&lt;String&gt; mySet) &#123;        this.mySet = mySet;    &#125;    public void setMyMap(Map&lt;String, String&gt; myMap) &#123;        this.myMap = myMap;    &#125;    public void setMyProp(Properties myProp) &#123;        this.myProp = myProp;    &#125;    @Override    public String toString() &#123;        return \"JavaCollection&#123;\" +                \"\\nmyStr=\" + Arrays.toString(myStr) +                \", \\nmyList=\" + myList +                \", \\nmySet=\" + mySet +                \", \\nmyMap=\" + myMap +                \", \\nmyProp=\" + myProp +                \"\\n&#125;\";    &#125;&#125;  \n\n配置文件\napplicationContext.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=\"jc\" class=\"com.ydx.domain.JavaCollection\" &gt;    &lt;property name=\"myStr\"&gt;        &lt;array&gt;            &lt;value&gt;aaa&lt;/value&gt;            &lt;value&gt;bbb&lt;/value&gt;            &lt;value&gt;ccc&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;property name=\"myList\"&gt;        &lt;list&gt;            &lt;value&gt;aaa&lt;/value&gt;            &lt;value&gt;bbb&lt;/value&gt;            &lt;value&gt;ccc&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name=\"mySet\"&gt;        &lt;set&gt;            &lt;value&gt;aaa&lt;/value&gt;            &lt;value&gt;bbb&lt;/value&gt;            &lt;value&gt;ccc&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;property name=\"myMap\"&gt;        &lt;map&gt;            &lt;entry key=\"test1\" value=\"aaa\" /&gt;            &lt;entry key=\"test2\"&gt;                &lt;value&gt;bbb&lt;/value&gt;            &lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;property name=\"myProp\"&gt;        &lt;props&gt;            &lt;prop key=\"test3\"&gt;ccc&lt;/prop&gt;            &lt;prop key=\"test4\"&gt;ddd&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;  \n\n测试类\nBaseTest.java12345678910111213141516171819package com.ydx;import com.ydx.domain.JavaCollection;import org.springframework.context.support.ClassPathXmlApplicationContext;public class BaseTest &#123;    /**     * 获取Spring的IoC核心容器，并根据id获取对象     * @param args     */    public static void main(String[] args) &#123;        //获取核心容器对象        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");        //根据id获取bean对象        JavaCollection jc = ac.getBean(\"jc\", JavaCollection.class);        System.out.println(jc.toString());    &#125;&#125;  \n\n运行结果：\n1234567JavaCollection&#123;myStr=[aaa, bbb, ccc], myList=[aaa, bbb, ccc], mySet=[aaa, bbb, ccc], myMap=&#123;test1=aaa, test2=bbb&#125;, myProp=&#123;test4=ddd, test3=ccc&#125;&#125;\n\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/a9caf4f0/"},{"title":"Spring框架入门3. Spring Bean","date":"2019-12-20T10:07:27.000Z","date_formatted":{"ll":"2019年12月20日","L":"2019/12/20","MM-DD":"12-20"},"updated":"2019-12-23T04:54:10.452Z","content":"Spring框架入门3. Spring BeanBeanbean 是被实例化，组装，并通过 Spring IoC 容器所管理的构成应用程序支柱的对象。这些 bean 是由用容器提供的配置元数据创建的\n在容器内部，这些 bean 定义被表示为 BeanDefinition 对象，其中包含以下元数据(以及其他信息):\n\n全限定类名：通常是定义的 bean 的实际实现类。\nbean 行为配置元素：它表示 bean 在容器中的行为(范围、生命周期回调，等等)。\n依赖：对该 bean 执行其工作所需的其他 bean 的引用。\n新创建的对象中的其他配置设置：例如，池的大小限制或管理连接池的 bean 中使用的连接数。\n\n上述所有的配置元数据转换成一组构成每个 bean 定义的下列属性：\n\n\n\n属性\n描述\n\n\n\nClass\n这个属性是强制性的，并且指定用来创建 bean 的 bean 类\n\n\nName\n这个属性指定唯一的 bean 标识符；在基于 XML 的配置元数据中，可以使用 id 和/或 name 属性来指定 bean 标识符\n\n\nScope\n这个属性指定由特定的 bean 定义创建的对象的作用域\n\n\nConstructor arguments\n依赖注入\n\n\nProperties\n依赖注入\n\n\nAutowiring mode\n自动装配\n\n\nLazy initialization mode\n延迟初始化的 bean ，告诉 IoC 容器在它第一次被请求时创建，而不是在启动时创建一个 bean 实例\n\n\nInitialization method\n在 bean 的所有必需的属性被容器设置之后，调用回调方法\n\n\nDestruction method\n当包含该 bean 的容器被销毁时，使用回调方法\n\n\n创建Bean对象的三种方式编写 service 层接口及其实现类作为测试用例：\nAccountService.java123456789101112package com.ydx.service;/*** 账户业务层的接口*/public interface AccountService &#123;  /**   * 模拟保存账户   */  void saveAccount();&#125;\n\nAccountServiceImpl.java1234567891011121314151617package com.ydx.service.impl;import com.ydx.service.AccountService;/** * 账户的业务层实现类 */public class AccountServiceImpl implements AccountService &#123;    public AccountServiceImpl() &#123;        System.out.println(\"AccountServiceImpl对象创建了\");    &#125;    public void saveAccount() &#123;        System.out.println(\"service中的saveAccount()方法执行了\");    &#125;&#125;\n\nBaseTest.java1234567891011121314151617181920package com.ydx;import com.ydx.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class BaseTest &#123;    /**     * 获取Spring的IoC核心容器，并根据id获取对象     * @param args     */    public static void main(String[] args) &#123;        //1 获取核心容器对象        ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");        //2 根据id获取bean对象        AccountService as = (AccountService) ac.getBean(\"accountService\");        as.saveAccount();    &#125;&#125;\n\n\n使用默认构造方法创建：\n它会根据默认无参构造方法来创建类对象。\n\n如果 bean 中没有默认无参构造方法，将会创建失败。\n\n\n在配置文件中添加标签\napplicationContext.xml12&lt;bean id=\"accountService\" class=\"com.ydx.service.impl.AccountServiceImpl\"/&gt;    \n\n运行结果\n12AccountServiceImpl对象创建了service中的saveAccount()方法执行了\n\n\n\n使用普通工厂中的方法创建\n使用某个类中的方法创建对象并存入 Spring 容器。\n\n模拟工厂类\n\n实际情况下，该类有可能存在于 jar 包中，我们无法通过修改源码的方式来提供默认构造方法。\n\nInstanceFactory.java123456789101112package com.ydx.factory;import com.ydx.service.AccountService;import com.ydx.service.impl.AccountServiceImpl;public class InstanceFactory &#123;  public AccountService getAccountService() &#123;      return new AccountServiceImpl();  &#125;&#125;    \n\n在配置文件中添加标签\napplicationContext.xml123&lt;bean id=\"instanceFactory\" class=\"com.ydx.factory.InstanceFactory\" /&gt;&lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getAccountService\" /&gt;    \n\n\nfactory-bean 属性指定了工厂类。factroy-method 属性指定使用哪一个方法获取对象。\n\n\n运行结果\n12AccountServiceImpl对象创建了service中的saveAccount()方法执行了\n\n\n\n使用工厂中的静态方法创建\n使用某个类中的静态方法创建对象并存入 Spring 容器。\n\n模拟工厂类\n\n实际情况下，该类有可能存在于 jar 包中，我们无法通过修改源码的方式来提供默认构造方法。\n\nStaticFactory.java1234567891011package com.ydx.factory;import com.ydx.service.AccountService;import com.ydx.service.impl.AccountServiceImpl;public class StaticFactory &#123;    public static AccountService getAccountService() &#123;        return new AccountServiceImpl();    &#125;&#125;    \n\n在配置文件中添加标签\napplicationContext.xml12&lt;bean id=\"accountService\" class=\"com.ydx.factory.StaticFactory\" factory-method=\"getAccountService\"/&gt;    \n\n运行结果\n12AccountServiceImpl对象创建了service中的saveAccount()方法执行了\n\n\n\n\n\nBean作用域和生命周期Bean作用域当在 Spring 中定义一个 bean 时，你必须在 scope 属性中声明该 bean 的作用域的选项。\nSpring 框架支持以下几个作用域：\n\n\n\n作用域\n描述\n\n\n\nsingleton\n在 Spring IoC 容器仅存在一个 bean 实例，bean 以单例方式存在，默认值\n\n\nprototype\n每次从容器中调用 bean 时，都返回一个新的实例，即每次调用 getBean() 时，相当于执行 newXxxBean()\n\n\nrequest\n每次 HTTP 请求都会创建一个新的 bean，该作用域仅适用于 ApplicationContext 环境\n\n\nsession\n同一个 HTTP Session 共享一个 bean，不同 Session 使用不同的 bean，仅适用于 ApplicationContext 环境\n\n\napplication\n将一个 bean 定义作用于 ServletContext 的生命周期，该作用域仅适用于 ApplicationContext 环境\n\n\nwebsocket\n将一个 bean 定义作用于 WebSocket 的生命周期，该作用域仅适用于 ApplicationContext 环境\n\n\n\n常用 singleton 和 prototype\n\nBean生命周期为了方便观察，在 AccountServiceImpl 中添加 init() 和 destroy() 方法\nAccountServiceImpl.java12345678910111213141516171819202122232425package com.ydx.service.impl;import com.ydx.service.AccountService;/** * 账户的业务层实现类 */public class AccountServiceImpl implements AccountService &#123;    public AccountServiceImpl() &#123;        System.out.println(\"AccountServiceImpl对象创建了\");    &#125;    public void  saveAccount() &#123;        System.out.println(\"service中的saveAccount()方法执行了\");    &#125;    public void  init() &#123;        System.out.println(\"AccountServiceImpl对象初始化了\");    &#125;    public void  destroy() &#123;        System.out.println(\"AccountServiceImpl对象销毁了\");    &#125;&#125;\n\n测试类：\nBaseTest.java1234567891011121314151617181920212223package com.ydx;import com.ydx.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class BaseTest &#123;    /**     * 获取Spring的IoC核心容器，并根据id获取对象     * @param args     */    public static void main(String[] args) &#123;        //获取核心容器对象        ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");        //根据id获取bean对象        AccountService as = (AccountService) ac.getBean(\"accountService\");        as.saveAccount();        //关闭容器        ac.close();    &#125;&#125;\n\n\n单例对象：scope=&quot;singleton&quot;\n一个应用只有一个对象的实例。它的作用范围就是整个引用。\n生命周期：\n\n对象出生：当应用加载，创建容器时，对象就被创建了。\n对象存活：只要容器在，对象一直存活。\n对象死亡：当应用卸载，销毁容器时，对象就被销毁了。\n\n配置文件：\napplicationContext.xml12&lt;bean id=\"accountService\" class=\"com.ydx.service.impl.AccountServiceImpl\" scope=\"singleton\" init-method=\"init\" destroy-method=\"destroy\"/&gt;  \n\n运行结果：\n1234AccountServiceImpl对象创建了AccountServiceImpl对象初始化了service中的saveAccount()方法执行了AccountServiceImpl对象销毁了\n\n\n容器关闭时，对象也就被销毁了\n\n\n多例对象：scope=&quot;prototype&quot;\n每次访问对象时，都会重新创建对象实例。\n生命周期：\n\n对象出生：当使用对象时，创建新的对象实例。\n对象存活：只要对象在使用中，就一直存活。\n对象死亡：当对象长时间不用时，被 Java 的垃圾回收器回收了。 \n\n配置文件：\napplicationContext.xml12&lt;bean id=\"accountService\" class=\"com.ydx.service.impl.AccountServiceImpl\" scope=\"prototype\" init-method=\"init\" destroy-method=\"destroy\"/&gt;  \n\n运行结果：\n123AccountServiceImpl对象创建了AccountServiceImpl对象初始化了service中的saveAccount()方法执行了\n\n\n即使关闭了容器，对象还会一直存在\n\n\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/9cc8ab67/"},{"title":"Spring框架入门2. Spring IoC容器","date":"2019-12-20T03:41:02.000Z","date_formatted":{"ll":"2019年12月20日","L":"2019/12/20","MM-DD":"12-20"},"updated":"2019-12-23T05:07:48.797Z","content":"Spring框架入门2. Spring IoC容器控制反转控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI）。\n通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递（注入）给它。\nIoC容器Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans。\n通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过 XML，Java 注解或 Java 代码来表示。下图是 Spring 如何工作的高级视图。 Spring IoC 容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。\n\nIoC 容器是具有依赖注入功能的容器，Spring 提供了以下两种不同类型的容器。\n\n\n\n容器\n描述\n\n\n\nBeanFactory\n该容器提供了框架和基本功能的配置\n\n\nApplicationContext\n该容器添加了更多的企业特定的功能\n\n\nBeanFactoryBeanFactory 是一个最简单的容器，它主要的功能是为依赖注入（DI）提供支持，这个容器接口在 org.springframework.beans.factory.BeanFactor 中被定义。BeanFactory 和相关的接口，比如 BeanFactoryAware、DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。\n在 Spring 中，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。\n在资源宝贵的移动设备或者基于 applet 的应用程序中，优先选择 BeanFactory。否则，一般使用的是 ApplicationContext。\nApplicationContextApplicationContext 是 BeanFactory 的子接口，也被成为 Spring 上下文。\nApplicationContext 是 Spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。另外，它增加了企业特定的功能，比如，从属性文件中解析文本信息和将事件传递给所指定的监听器。这个容器接口在 org.springframework.context.ApplicationContext 接口中被定义。\nApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。当然，BeanFactory 仍可以在轻量级应用中使用，比如移动设备或者基于 applet 的应用程序。\nApplicationContext 接口最常被使用的实现类：\n\nClassPathXmlApplicationContext：该容器从类路径下的配置文件中加载已被定义的 bean。使用该容器不需要提供配置文件的完整路径，只需正确配置 CLASSPATH 环境变量即可。\nFileSystemXmlApplicationContext：该容器从磁盘任意路径下的配置文件中加载已被定义的 bean。使用该容器需要注意路径必须要有访问权限。\nWebXmlApplicationContext：该容器会在一个 Web 应用程序的范围内加载在配置文件中已被定义的 bean。\nAnnotationConfigApplicationContext：它是用于读取注解创建容器的。\n\nBeanFactory 和 ApplicationContext 的区别\nBeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext 是它的子接口。\n\n创建对象的时间点不一样：\n\nApplicationContext：它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。\nBeanFactory：它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据 id 获取对象了，什么时候才真正的创建对象。\n\n\n\n基于 XML 的 IoC 环境搭建\nMaven pom.xml 配置\npom.xml123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.ydx&lt;/groupId&gt;    &lt;artifactId&gt;spring-learn&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;  \n\n编写程序代码\n\n编写 dao 层接口及其实现类\nAccountDao.java12345678910111213package com.ydx.dao;/** * 账户的持久层接口 */public interface AccountDao &#123;    /**     * 模拟保存账户     */    void saveAccount();&#125;    \n\nAccountDaoImpl.java123456789101112131415161718package com.ydx.dao.impl;import com.ydx.dao.AccountDao;/** * 账户的持久层实现类 */public class AccountDaoImpl implements AccountDao &#123;    public AccountDaoImpl() &#123;        System.out.println(\"AccountDaoImpl对象创建了\");    &#125;    public void saveAccount() &#123;        System.out.println(\"保存了账户\");    &#125;&#125;    \n\n编写 service 层接口及其实现类\nAccountService.java12345678910111213package com.ydx.service;/** * 账户业务层的接口 */public interface AccountService &#123;    /**     * 模拟保存账户     */    void saveAccount();&#125;    \n\nAccountServiceImpl.java123456789101112131415161718192021package com.ydx.service.impl;import com.ydx.dao.AccountDao;import com.ydx.service.AccountService;/** * 账户的业务层实现类 */public class AccountServiceImpl implements AccountService &#123;    private AccountDao accountDao ;    public AccountServiceImpl() &#123;        System.out.println(\"AccountServiceImpl对象创建了\");    &#125;    public void  saveAccount() &#123;        accountDao.saveAccount();    &#125;&#125;    \n\n\n\nresourse 目录下新建 applicationContext.xml\napplicationContext.xml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans                https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;    &lt;!--把对象的创建交给Spring来管理--&gt;    &lt;bean id=\"accountService\" class=\"com.ydx.service.impl.AccountServiceImpl\"/&gt;    &lt;bean id=\"accountDao\" class=\"com.ydx.dao.impl.AccountDaoImpl\"/&gt;&lt;/beans&gt;  \n\n\nid 属性是标识单个 bean 定义的字符串。class 属性使用全限定类名定义 bean 的类型。\n\n\n编写测试类，调用 service 接口\nBaseTest.java1234567891011121314151617181920212223242526package com.ydx;import com.ydx.dao.AccountDao;import com.ydx.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class BaseTest &#123;    /**     * 获取Spring的IoC核心容器，并根据id获取对象     * @param args     */    public static void main(String[] args) &#123;        //1 获取核心容器对象        ApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");        //2 根据id获取bean对象        AccountService as = (AccountService) ac.getBean(\"accountService\");        AccountDao ad = ac.getBean(\"accountDao\", AccountDao.class);        System.out.println(as);        System.out.println(ad);    &#125;&#125;  \n\n\n这里使用了 getBean() 方法的两种用法，getBean(String name) 和 getBean(String name, Class requiredType)\n\n运行结果：\n1234AccountServiceImpl对象创建了AccountDaoImpl对象创建了com.ydx.service.impl.AccountServiceImpl@57baeedfcom.ydx.dao.impl.AccountDaoImpl@343f4d3d\n\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/865c5d02/"},{"title":"设计模式8 代理模式","date":"2019-12-05T08:27:00.000Z","date_formatted":{"ll":"2019年12月5日","L":"2019/12/05","MM-DD":"12-05"},"updated":"2019-12-06T10:34:39.559Z","content":"设计模式8 代理模式代理模式(Proxy Pattern 或 Surrogate Pattern)是一种对象结构型模式。\n代理模式定义\n代理模式：\n给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。\n\n代理模式和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。\n和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\n\n代理模式优缺点：\n优点：\n\n代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。\n代理对象可以扩展目标对象的功能。\n代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度。\n\n缺点：\n\n客户端和目标对象之间增加了一个代理对象，请求处理速度变慢。\n实现代理模式需要额外的工作，有些代理模式的实现非常复杂，增加了系统的复杂度。\n\n\n\n代理模式结构\n代理模式主要包括以下主要角色：\n\n抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。\n真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\n代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\n\n\n代理模式类图：\n\n\n\n代理模式实现方法\n抽象主题接口\n声明真实主题和代理对象实现的业务方法：\n123interface Subject &#123;    void Request();&#125;\n\n真实主题类\n实现了抽象主题中的具体业务：\n12345class RealSubject implements Subject &#123;    public void Request() &#123;        System.out.println(\"访问真实主题方法...\");    &#125;&#125;\n\n代理类\n访问、控制或扩展真实主题的功能：\n1234567891011121314151617181920class Proxy implements Subject &#123;    private RealSubject realSubject;    public void Request() &#123;        if (realSubject == null) &#123;            realSubject = new RealSubject();        &#125;        preRequest();        realSubject.Request();        postRequest();    &#125;    public void preRequest() &#123;        System.out.println(\"访问真实主题之前的预处理。\");    &#125;    public void postRequest() &#123;        System.out.println(\"访问真实主题之后的后续处理。\");    &#125;&#125;\n\n访问类\n123456public class Client &#123;    public static void main(String[] args) &#123;        Proxy proxy = new Proxy();        proxy.Request();    &#125;&#125;\n\n\n\n代理模式扩展动态代理模式：\n\n动态代理是一种较为高级的代理模式，它的典型应用就是Spring AOP。\n\n在传统的代理模式中，客户端通过 Proxy 调用 RealSubject 类的 request() 方法，同时还在代理类中封装了其他方法（如 preRequest() 和 postRequest()），可以处理一些其他问题。\n\n如果按照这种方法使用代理模式，那么真实主题角色必须是事先已经存在的，并将其作为代理对象的内部成员属性。如果一个真实主题角色必须对应一个代理主题角色，这将导致系统中的类个数急剧增加，因此需要想办法减少系统中类的个数，此外，如何在事先不知道真实主题角色的情况下使用代理主题角色，这都是动态代理需要解决的问题。\n动态代理模式如下图所示：\n\n\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/426b71cf/"},{"title":"设计模式7 建造者模式","date":"2019-12-03T06:34:02.000Z","date_formatted":{"ll":"2019年12月3日","L":"2019/12/03","MM-DD":"12-03"},"updated":"2019-12-06T08:34:40.625Z","content":"设计模式7 建造者模式建造者模式(Builder Pattern)，也称为生成器模式，属于对象创建型模式。\n建造者模式定义\n建造者模式：\n将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。\n建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。\n\n建造者模式优缺点：\n优点：\n\n客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\n每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换或增加具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。\n可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\n增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。\n\n缺点：\n\n建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\n如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。\n\n\n\n建造者模式结构\n建造者模式主要包括以下主要角色：\n\n产品（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。\n抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。\n具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。\n指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。\n\n\n建造者模式类图：\n\n\n\n建造者模式实现方法\n产品类\n包含多个组成部件的复杂对象：\n123456789101112131415161718192021class Product &#123;    private String partA;    private String partB;    private String partC;    public void setPartA(String partA) &#123;        this.partA = partA;    &#125;    public void setPartB(String partB) &#123;        this.partB = partB;    &#125;    public void setPartC(String partC) &#123;        this.partC = partC;    &#125;    public void show() &#123;        //显示产品的特性    &#125;&#125;\n\n抽象建造者抽象类\n包含创建产品各个子部件的抽象方法：\n12345678910111213abstract class Builder &#123;    //创建产品对象    protected Product product = new Product();    public abstract void buildPartA();    public abstract void buildPartB();    public abstract void buildPartC();    //返回产品对象    public Product getResult() &#123;        return product;    &#125;&#125;\n\n具体建造者\n继承了了抽象建造者抽象类：\n12345678910111213public class ConcreteBuilder extends Builder &#123;    public void buildPartA() &#123;        product.setPartA(\"建造 PartA\");    &#125;    public void buildPartB() &#123;        product.setPartA(\"建造 PartB\");    &#125;    public void buildPartC() &#123;        product.setPartA(\"建造 PartC\");    &#125;&#125;\n\n指挥者\n调用建造者中的方法完成复杂对象的创建：\n123456789101112131415class Director &#123;    private Builder builder;    public Director(Builder builder) &#123;        this.builder = builder;    &#125;    //产品构建与组装方法    public Product construct() &#123;        builder.buildPartA();        builder.buildPartB();        builder.buildPartC();        return builder.getResult();    &#125;&#125;\n\n访问类\n12345678public class Client &#123;    public static void main(String[] args) &#123;        Builder builder = new ConcreteBuilder();        Director director = new Director(builder);        Product product = director.construct();        product.show();    &#125;&#125;\n\n\n\n建造者模式扩展建造者模式的简化：\n\n省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。\n省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让 Builder 角色扮演指挥者与建造者双重角色。\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/4789/"},{"title":"设计模式6 抽象工厂模式","date":"2019-12-03T02:21:55.000Z","date_formatted":{"ll":"2019年12月3日","L":"2019/12/03","MM-DD":"12-03"},"updated":"2019-12-03T11:04:16.071Z","content":"设计模式6 抽象工厂模式抽象工厂模式(Abstract Factory Pattern)，也称为Kit模式，属于对象创建型模式。\n抽象工厂模式定义\n抽象工厂模式：\n提供一个创建一系列相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\n抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\n\n抽象工厂模式特点：\n“开闭原则”的倾斜性：“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：\n\n增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。\n增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。\n\n抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。\n\n抽象工厂模式优缺点：\n优点：\n\n可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。\n当增加一个新的产品族时不需要修改原代码，满足开闭原则。\n\n缺点：\n\n当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。\n\n\n\n抽象工厂模式结构\n抽象工厂模式主要包括以下主要角色：\n\n抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。\n具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\n抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\n具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。\n\n\n抽象工厂模式类图：\n\n\n\n抽象工厂模式实现方法抽象工厂模式的结构同工厂方法模式的结构相似，不同的是其产品的种类不止一个，所以创建产品的方法也不止一个。\n下面只给出抽象工厂和具体工厂的代码：\n\n抽象工厂类\n抽象工厂提供了不同产品的生成方法：\n1234interface AbstractFactory &#123;    public ProductA newProductA();    public ProductB newProductB();&#125;\n\n具体工厂类\n具体工厂实现了不同产品的生成方法：\n1234567891011121314151617181920212223class ConcreteFactory1 implements AbstractFactory &#123;    public ProductA newProductA() &#123;        System.out.println(\"具体工厂1生成--&gt;具体产品A1...\");        return new ConcreteProductA1();    &#125;    public ProductB newProductB() &#123;        System.out.println(\"具体工厂1生成--&gt;具体产品B1...\");        return new ConcreteProductB1();    &#125;&#125;class ConcreteFactory2 implements AbstractFactory &#123;    public ProductA newProductA() &#123;        System.out.println(\"具体工厂2生成--&gt;具体产品A2...\");        return new ConcreteProductA2();    &#125;    public ProductB newProductB() &#123;        System.out.println(\"具体工厂2生成--&gt;具体产品B2...\");        return new ConcreteProductB2();    &#125;&#125;\n\n\n\n抽象工厂模式扩展\n当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式。\n当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/18608/"},{"title":"设计模式5 工厂方法模式","date":"2019-12-02T05:57:36.000Z","date_formatted":{"ll":"2019年12月2日","L":"2019/12/02","MM-DD":"12-02"},"updated":"2019-12-03T11:04:16.074Z","content":"设计模式5 工厂方法模式工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它是一种类创建型模式。\n工厂方法模式定义定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。\n\n工厂方法模式优缺点：\n优点：\n\n一个调用者想创建一个产品，只需知道其名称即可。\n扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。\n屏蔽产品的具体实现，调用者只关心产品的接口。\n\n缺点：\n\n每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。 \n\n\n\n工厂方法模式结构\n工厂方法模式主要包括以下主要角色：\n\n抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。\n具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。\n抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。\n具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。\n\n\n工厂方法模式类图：\n\n\n\n工厂方法模式实现方法\n抽象产品类\n抽象产品类提供了产品的接口：\n123interface Product &#123;    public void show();&#125;\n\n具体产品类\n具体产品实现了抽象产品中的抽象方法：\n1234567891011class ConcreteProduct1 implements Product &#123;    public void show() &#123;        System.out.println(\"具体产品1显示...\");    &#125;&#125;class ConcreteProduct2 implements Product &#123;    public void show() &#123;        System.out.println(\"具体产品2显示...\");    &#125;&#125;\n\n抽象工厂类\n抽象工厂提供了产品的生成方法：\n123interface AbstractFactory &#123;    public Product newProduct();&#125;\n\n具体工厂类\n具体工厂实现了产品的生成方法：\n12345678910111213class ConcreteFactory1 implements AbstractFactory &#123;    public Product newProduct() &#123;        System.out.println(\"具体工厂1生成--&gt;具体产品1...\");        return new ConcreteProduct1();    &#125;&#125;class ConcreteFactory2 implements AbstractFactory &#123;    public Product newProduct() &#123;        System.out.println(\"具体工厂2生成--&gt;具体产品2...\");        return new ConcreteProduct2();    &#125;&#125;\n\n访问类\n访问类通过调用具体工厂类的方法，从而创建不同具体产品类的实例：\n1234567891011public class Client &#123;    public static void main(String[] args) &#123;        //生产产品1        ConcreteFactory1 f1 = new ConcreteFactory1();        f1.newProduct().show();        //生产产品2        ConcreteFactory2 f2 = new ConcreteFactory2();        f2.newProduct().show();    &#125;&#125;\n\n\n\n工厂方法模式扩展\n使用多个工厂方法：在抽象工厂角色中可以定义多个工厂方法，从而使具体工厂角色实现这些不同的工厂方法，这些方法可以包含不同的业务逻辑，以满足对不同的产品对象的需求。\n\n产品对象的重复使用：工厂对象将已经创建过的产品保存到一个集合（如数组、List等）中，然后根据客户对产品的请求，对集合进行查询。如果有满足要求的产品对象，就直接将该产品返回客户端；如果集合中没有这样的产品对象，那么就创建一个新的满足要求的产品对象，然后将这个对象在增加到集合中，再返回给客户端。\n\n多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生了退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法时，工厂方法模式就退化成简单工厂模式。\n简单工厂模式如下图所示：\n\n\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/57053/"},{"title":"设计模式4 原型模式","date":"2019-11-28T08:32:46.000Z","date_formatted":{"ll":"2019年11月28日","L":"2019/11/28","MM-DD":"11-28"},"updated":"2019-12-03T11:04:16.066Z","content":"设计模式4 原型模式原型模式（Prototype Pattern）是一种对象创建型模式。\n原型模式定义原型模式实现了一个原型接口，并用其实例作为原型，通过克隆该原型对象来创建一个和原型相同或相似的新对象。原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。\n原型模式结构\n原型模式主要包括以下主要角色：\n\n原型接口/抽象原型类\n具体原型类\n访问类\n\n\n原型模式类图：\n\n\n\n原型模式实现方法\n原型接口/抽象原型类\n原型模式的克隆分为浅克隆和深克隆，Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类\n\n具体原型类\n12345678class Realizetype implements Cloneable &#123;    Realizetype() &#123;    &#125;    public Object clone() throws CloneNotSupportedException &#123;        return (Realizetype)super.clone();    &#125;&#125;\n\n访问类\n123456public class Client &#123;    public static void main(String[] args) throws CloneNotSupportedException &#123;        Realizetype obj1 = new Realizetype();        Realizetype obj2 = (Realizetype)obj1.clone();    &#125;&#125;\n\n\n\n原型模式扩展原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/64779/"},{"title":"设计模式3 单例模式","date":"2019-11-24T08:56:42.000Z","date_formatted":{"ll":"2019年11月24日","L":"2019/11/24","MM-DD":"11-24"},"updated":"2019-12-03T11:04:16.065Z","content":"设计模式3 单例模式单例模式(Singleton Pattern)是一种对象创建型模式。单例模式又名单件模式或单态模式。\n单例模式定义\n单例模式：\n单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。\n\n单例模式的要点：\n\n单例类只能有一个实例；\n单例类必须自己创建自己的唯一实例；\n单例类必须对外提供一个访问该实例的全局访问点。\n\n\n单例模式优缺点：\n优点：\n\n提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。\n系统内存中只存在一个对象，节约系统资源，尤其适用一些需要频繁创建和销毁的对象，可以提高系统的性能。\n允许可变数目的实例。可基于单例模式进行扩展，使用与单例控制相似的方式来获得指定个数的对象实例。\n\n缺点：\n\n由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。\n单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。\n滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。\n\n\n\n单例模式结构\n单例模式类图：\n\n\n\n单例模式实现方式懒汉式（线程不安全）  最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式懒加载很明显，不要求线程安全，在多线程不能正常工作。\n  12345678910111213public class Singleton &#123;    private static Singleton instance;    private Singleton() &#123;    &#125;    public static Singleton getInstance() &#123;        if (instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;\n\n懒汉式（线程安全）  这种方式具备很好的懒加载，能够在多线程中很好的工作，但是效率很低，绝大多数情况下不需要同步。\n  12345678910111213public class Singleton &#123;    private static Singleton instance;    private Singleton() &#123;    &#125;    public static synchronized Singleton getInstance() &#123;        if (instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;\n\n饿汉式  较常用的实现方式，但没有懒加载效果，容易产生垃圾对象。\n  12345678910public class Singleton &#123;    private static Singleton instance = new Singleton();    private Singleton() &#123;    &#125;    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;\n\n双检锁（DCL，即 double-checked locking，双重校验锁）  这种方式采用双锁机制，安全且在多线程情况下能保持高性能。\n  1234567891011121314151617public class Singleton &#123;    private volatile static Singleton singleton;      private Singleton() &#123;    &#125;    public static Singleton getInstance() &#123;        if (instance == null) &#123;            synchronized (Singleton.class) &#123;                if (instance == null) &#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return singleton;    &#125;&#125;\n\n登记式/静态内部类  这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用懒加载，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要懒加载时使用。\n  123456789101112public class Singleton &#123;     private Singleton() &#123;    &#125;      public static Singleton getInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;    private static class SingletonHolder &#123;        private static final Singleton INSTANCE = new Singleton();    &#125;&#125;\n\n枚举  枚举方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。\n  12345public enum Singleton &#123;    INSTANCE;    public void doSomeThing() &#123;    &#125;&#125;\n\n  注意\n  枚举单例的优点就是简单，但大部分应用开发很少用枚举，可读性不高，不建议使用，上述几种实现方式中，反序列化将会会破坏单例模式，可以添加如下方法来防止单例对象被反序列化时重新生成对象：  123private Object readResolve() throws ObjectStreamException &#123;    return singleton;&#125;\n实现方式对比表：\n\n\n\n\n懒加载\n线程安全\n实现难度\nJDK版本\n\n\n\n懒汉式（线程不安全）\n是\n否\n易\n*\n\n\n懒汉式（线程安全）\n是\n是\n易\n*\n\n\n饿汉式\n否\n是\n是\n*\n\n\n双检锁\n是\n是\n较难\nJDK1.5+\n\n\n登记式\n是\n是\n一般\n*\n\n\n枚举\n否\n是\n易\nJDK1.5+\n\n\n一般情况下，不建议使用第 1、2 种懒汉式，建议使用第 3 种饿汉式。只有在要明确实现懒加载效果时，才会使用第 5 种登记式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。\n单例模式扩展单例模式可扩展为有限的多例（Multiton）模式，这种模式可生成有限个实例并保存在 ArrayList 中，用户需要时可随机获取。\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/54829/"},{"title":"设计模式2 UML类图与时序图简介","date":"2019-11-22T06:34:45.000Z","date_formatted":{"ll":"2019年11月22日","L":"2019/11/22","MM-DD":"11-22"},"updated":"2019-12-03T11:04:16.063Z","content":"设计模式2 UML类图与时序图简介类图示例请看以下这个类图，类之间的关系是我们需要关注的：\n\n\n车的类图结构为&lt;&lt;abstract&gt;&gt;，表示车是一个抽象类；\n其他的类为实体类。\n\n成员成员书写规范：\n修饰符 [描述信息] 属性或方法名称([参数]) [：返回类型|类型[ = 默认值]]。UML类图中类成员（即任何属性或方法）的可见性由下列符号所示：\n\n-：共有\n+：私有\n#：收保护\n~：包\n/：推导\n__：静态\n\n\n< >>","color":"#EBF8FF","plink":"http://alpac.top/articles/48322/"},{"title":"设计模式1 设计模式概述","date":"2019-11-22T05:00:04.000Z","date_formatted":{"ll":"2019年11月22日","L":"2019/11/22","MM-DD":"11-22"},"updated":"2019-12-03T11:04:16.083Z","content":"设计模式1 设计模式概述软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。\n设计模式背景“设计模式”这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。\n1977 年，美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。\n1979 年他的另一部经典著作《建筑的永恒之道》（The Timeless Way of Building）进一步强化了设计模式的思想，为后来的建筑设计指明了方向。\n1987 年，肯特·贝克（Kent Beck）和沃德·坎宁安（Ward Cunningham）首先将克里斯托夫·亚历山大的模式思想应用在 Smalltalk 中的图形用户接口的生成中，但没有引起软件界的关注。\n直到 1990 年，软件工程界才开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。\n1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在书中提出了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。他们所提出的设计模式主要是基于以下的面向对象设计原则。\n\n对接口编程而不是对实现编程。\n优先使用对象组合而不是继承。\n\n直到今天，狭义的设计模式还是这 23 种经典设计模式。这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。\n当然，软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择：\n\n对于简单的程序，可能写一个简单的算法要比引入某种设计模式更加容易；\n但是对于大型项目开发或者框架设计，用设计模式来组织代码显然更好。\n\n\n学习设计模式的意义设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点：\n\n可以提高程序员的思维能力、编程能力和设计能力。\n使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。\n使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。\n\nGoF 的 23 种设计模式与设计模式原则设计模式的分类\n根据目的来分\n根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。\n\n创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。\n结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。\n行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。\n\n\n根据作用范围来分\n根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。\n\n类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。\n对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。\n\n\n\n\n\n\n范围\\目的\n创建型模式\n结构型模式\n行为型模式\n\n\n\n类模式\n工厂方法模式\n(类）适配器模式\n模板方法模式解释器模式\n\n\n对象模式\n单例模式原型模式抽象工厂模式建造者模式\n代理模式(对象）适配器模式桥接模式装饰模式外观模式享元模式组合模式\n策略模式命令模式职责链模式状态模式观察者模式中介者模式迭代器模式访问者模式备忘录模式\n\n\nGoF 的 23 种设计模式的功能前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。\n\n创建型模式：\n创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。\n\n单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。\n原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。\n工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。\n抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。\n建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。\n\n\n结构型模式：\n结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\n\n代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。\n适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\n桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\n装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。\n外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。\n享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。\n组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。\n\n\n行为型模式：\n行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。\n\n模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\n策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。\n命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。\n职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。\n状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。\n观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。\n中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。\n迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。\n访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。\n备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。\n解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。\n\n\n\n设计模式原则\n开闭原则（Open Close Principle）：对扩展开放，对修改关闭。\n里氏替换原则（Liskov Substitution Principle）：子类可以扩展父类的功能，但不能改变父类原有的功能。\n依赖倒置原则（Dependence Inversion Principle）：通过要面向接口的编程来降低类间的耦合性。\n单一职责原则（Single-Responsibilitiy Principle）：对象（类）不应该承担太多职责。\n接口隔离原则（Interface Segregation Principle）：将臃肿庞大的接口拆分成更小的和更具体的接口。\n迪米特法则（Demeter Principle）：只与你的直接朋友交谈，不跟“陌生人”说话。\n合成复用原则（Composite Reuse Principle）：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/24494/"},{"title":"Spring框架入门1. Spring概述","date":"2019-11-21T02:28:33.000Z","date_formatted":{"ll":"2019年11月21日","L":"2019/11/21","MM-DD":"11-21"},"updated":"2019-12-23T04:53:39.311Z","content":"Spring框架入门1. Spring概述简介Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。\nSpring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。\n\n目的：解决企业应用开发的复杂性\n功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能\n范围：任何Java应用\n\n\n官方网站：https://spring.io/\n官方下载：https://repo.spring.io/release/org/springframework/spring/\n官方Github：https://github.com/spring-projects/spring-framework\n\n123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\nSpring优点\n方便解耦，简化开发\n通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。\n\nAOP编程的支持\n通过 Spring 的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付。\n\n声明式事务的支持\n可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。\n\n方便程序的测试\n可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。\n\n方便集成各种优秀框架\nSpring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz 等）的直接支持。\n\n降低 JavaEE API 的使用难度\nSpring 对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的 使用难度大为降低。\n\nJava源码是经典学习范例\nSpring 的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。 \n\n\nSpring核心模块\n","color":"#EBF8FF","plink":"http://alpac.top/articles/26865/"},{"title":"MyBatis框架入门六. MyBatis动态SQL语句","date":"2019-11-19T07:22:51.000Z","date_formatted":{"ll":"2019年11月19日","L":"2019/11/19","MM-DD":"11-19"},"updated":"2019-12-20T08:17:40.365Z","content":"MyBatis框架入门六. MyBatis动态SQL语句if标签\n在dao接口中添加方法\n 123456/** * 根据输入参数条件查询用户 * @param user 查询的条件，有可能有用户名、性别、地址等条件 * @return */List&lt;User&gt; findByCondition(User user);\n\n在映射配置文件中添加配置\n 1234567&lt;!-- 根据输入参数条件查询用户--&gt;&lt;select id=\"findByCondition\" parameterType=\"com.ydx.domain.User\" resultType=\"com.ydx.domain.User\"&gt;    SELECT * FROM user WHERE 1 = 1    &lt;if test=\"username != null\"&gt;        AND username LIKE #&#123;username&#125;;    &lt;/if&gt;&lt;/select&gt;\n\n在测试类中添加测试方法\n 1234567891011121314/** * 测试根据输入参数条件查询用户 */@Testpublic void testFindByCondition() &#123;    User user = new User();    user.setUsername(\"老王\");        //执行根据输入参数条件查询用户    List&lt;User&gt; users = userDao.findByCondition(user);    for (User u : users) &#123;        System.out.println(u);    &#125;&#125;\n\n\n\nwhere标签\n在映射配置文件中修改配置\n 123456789101112&lt;!-- 根据输入参数条件查询用户--&gt;&lt;select id=\"findByCondition\" parameterType=\"com.ydx.domain.User\" resultType=\"com.ydx.domain.User\"&gt;    SELECT * FROM user    &lt;where&gt;        &lt;if test=\"username != null\"&gt;            AND username LIKE #&#123;username&#125;        &lt;/if&gt;        &lt;if test=\"sex != null\"&gt;            AND sex LIKE #&#123;sex&#125;;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n在测试类中修改测试方法\n 123456789101112131415/** * 测试根据输入参数条件查询用户 */@Testpublic void testFindByCondition() &#123;    User user = new User();    user.setUsername(\"老王\");    user.setSex(\"女\");       //执行根据输入参数条件查询用户    List&lt;User&gt; users = userDao.findByCondition(user);    for (User u : users) &#123;        System.out.println(u);    &#125;&#125;\n\n\n\nforeach标签\n利用QueryVo，添加属性ids表示用户的id集合，并生成get、set方法\n 123456789private List&lt;Integer&gt; ids;    public List&lt;Integer&gt; getIds() &#123;    return ids;&#125;    public void setIds(List&lt;Integer&gt; ids) &#123;    this.ids = ids;&#125;\n\n在dao接口中添加方法\n 123456/** * 根据QueryVo中提供的用户id查询用户 * @param vo * @return */List&lt;User&gt; findByIds(QueryVo vo);\n\n在映射配置文件中添加配置\n 1234567891011&lt;!-- 根据QueryVo中提供的用户id查询用户--&gt;&lt;select id=\"findInIds\" parameterType=\"com.ydx.domain.QueryVo\" resultType=\"com.ydx.domain.User\"&gt;    SELECT * FROM user    &lt;where&gt;        &lt;if test=\"ids != null and ids.size() &gt; 0\"&gt;            &lt;foreach collection=\"ids\" open=\"id IN (\" close=\")\" item=\"uid\" separator=\", \"&gt;                #&#123;uid&#125;            &lt;/foreach&gt;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n在测试类中添加测试方法\n 123456789101112131415161718/** * 测试根据QueryVo中提供的用户id查询用户 */@Testpublic void testFindInIds() &#123;    QueryVo vo = new QueryVo();    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();    list.add(41);    list.add(42);    list.add(43);    vo.setIds(list);        //执行根据QueryVo中提供的用户id查询用户    List&lt;User&gt; users = userDao.findInIds(vo);    for (User user : users) &#123;        System.out.println(user);    &#125;&#125;\n\n\n\nsql标签与include标签sql标签和include标签可以抽取重复的SQL语句。\n\n在映射配置文件中添加配置\n 1234&lt;!-- 抽取重复的SQL语句--&gt;&lt;sql id=\"defaultTable\"&gt;    SELECT * FROM user&lt;/sql&gt;\n\n修改其他配置\n 1234567891011&lt;!-- 根据QueryVo中提供的用户id查询用户--&gt;&lt;select id=\"findInIds\" parameterType=\"com.ydx.domain.QueryVo\" resultType=\"com.ydx.domain.User\"&gt;    &lt;include refid=\"defaultTable\"/&gt;    &lt;where&gt;        &lt;if test=\"ids != null and ids.size() &gt; 0\"&gt;            &lt;foreach collection=\"ids\" open=\"id IN (\" close=\")\" item=\"uid\" separator=\", \"&gt;                #&#123;uid&#125;            &lt;/foreach&gt;        &lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;\n\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/29950/"},{"title":"MyBatis框架入门五. MyBatis事务","date":"2019-11-19T07:04:34.000Z","date_formatted":{"ll":"2019年11月19日","L":"2019/11/19","MM-DD":"11-19"},"updated":"2019-12-20T08:17:36.599Z","content":"MyBatis框架入门五. MyBatis事务什么是事务事务的四大特性（ACID）\n原子性(Atomicity)：\n  整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。\n  事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n一致性(Correspondence)：\n  在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\n\n隔离性(Isolation)：\n  隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。\n  如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。\n  这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。\n\n持久性(Durability)：\n  在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\n\n不考虑事务隔离性会产生的3个问题四种隔离级别MyBatis中的事务MyBatis通过sqlSession对象的commit()方法和rollback()方法实现事务的提交和回滚。\n","color":"#EBF8FF","plink":"http://alpac.top/articles/61215/"},{"title":"MyBatis框架入门四. MyBatis连接池","date":"2019-11-19T06:10:08.000Z","date_formatted":{"ll":"2019年11月19日","L":"2019/11/19","MM-DD":"11-19"},"updated":"2019-12-20T08:17:43.846Z","content":"MyBatis框架入门四. MyBatis连接池连接池在实际开发中使用连接池可以减少我们获取连接所获取的时间。\nMyBatis中的连接池配置位置：主配置文件sqlMapConfig.xml中的dataSource标签的type属性。\nMyBatis连接池提供了3中配置方式（type属性的三种取值）：\n\nPOOLED：\n  采用传统的javax.sql.DataSource规范中的连接池，MyBatis中有针对规范的实现。\n  如果将type属性设置成POOLED，MyBatis会创建一个数据库连接池，连接池中的一个连接将会被用作数据操作；一旦数据库操作完成，MyBatis会将此连接返回给连接池。\n  在开发或测试环境中，经常使用此种方式\n\nUNPOOLED：\n  采用传统的连接方式，也是实现了javax.sql.DataSource规范中的接口，但是并没有使用池的思想。\n  如果将type属性设置成POOLED，MyBatis会为每一个数据库操作创建一个新的连接，并关闭它。\n  该方式适用于只有小规模数量并发用户的简单应用程序上。\n\nJNDI：\n  Java Naming and Directory Interface。是SUN公司推出的一套规范，属于JavaEE技术之一。目的是模仿windows系统中的注册表。JNDI采用服务器提供的JNDI技术实现，来获取DataSource对象，不同服务器所能拿到的DataSource是不一样的。\n  在生产环境中优先考虑这种方式。\n  注意：如果不是web或Maven war工程，则不能使用。\n\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/26164/"},{"title":"MyBatis框架入门三. MyBatis基于XML的CRUD操作","date":"2019-11-16T15:29:39.000Z","date_formatted":{"ll":"2019年11月16日","L":"2019/11/16","MM-DD":"11-16"},"updated":"2019-12-20T08:17:28.692Z","content":"MyBatis框架入门三. MyBatis基于XML的CRUD操作基于代理dao实现CRUD操作使用要求：\n\n持久层接口和持久层接口的映射配置必须在相同的包下；\n持久层映射配置中 mapper 标签的 namespace 属性取值必须是持久层接口的全限定类名；\nSQL 语句的配置标签 &lt;select&gt;、&lt;insert&gt;、&lt;delete&gt;、&lt;update&gt; 的 id 属性必须和持久层接口的方法名相同。 \n\n查询所有用户\n在dao接口中添加方法\n 12345 /** * 查询所有用户 * @return */List&lt;User&gt; findAll();\n\n在映射配置文件中添加配置\n 1234&lt;!-- 配置查询所有用户，id要写方法名称, resultType要写返回类型--&gt;&lt;select id=\"findAll\" resultType=\"com.ydx.domain.User\"&gt;    SELECT * FROM user;&lt;/select&gt;\n\n在测试类中添加测试方法\n 1234567891011/** * 测试查询所有用户操作 */@Testpublic void testFindAll()&#123;    //使用代理对象执行方法    List&lt;User&gt; users = userDao.findAll();    for (User user: users) &#123;        System.out.println(user);    &#125;&#125;\n\n\n\n插入用户\n在dao接口中添加方法\n 12345/** * 插入用户 * @param user */void insertUser(User user);\n\n在映射配置文件中添加配置\n 1234&lt;!-- 插入用户--&gt;&lt;insert id=\"insertUser\"&gt;    INSERT INTO user(username, address, sex, birthday) VALUES(#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;);&lt;/insert&gt;\n\n在测试类中添加测试方法\n 1234567891011121314/** * 测试插入用户操作 */@Testpublic void testInsertUser() &#123;    User user = new User();    user.setUsername(\"杨得轩\");    user.setAddress(\"上海\");    user.setSex(\"男\");    user.setBirthday(new Date());       //执行插入用户方法    userDao.insertUser(user);&#125;\n\n\n\n插入用户并返回其id\n在dao接口中添加方法\n 123456/** * 插入用户并返回其id * @param user * @return */int insertUser2(User user);\n\n在映射配置文件中添加配置\n 12345678&lt;!-- 插入用户并返回其id--&gt;&lt;insert id=\"insertUser2\"&gt;    &lt;!-- 返回最后插入的用户的id--&gt;    &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\"&gt;        SELECT LAST_INSERT_ID();    &lt;/selectKey&gt;    INSERT INTO user(username, address, sex, birthday) VALUES(#&#123;username&#125;, #&#123;address&#125;, #&#123;sex&#125;, #&#123;birthday&#125;);&lt;/insert&gt;\n\n在测试类中添加测试方法\n 1234567891011121314/** * 测试插入用户操作，并返回其id */@Testpublic void testInsertUser2() &#123;    User user = new User();    user.setUsername(\"杨得轩\");    user.setAddress(\"上海\");    user.setSex(\"男\");    user.setBirthday(new Date());        //执行插入用户方法    userDao.insertUser(user);&#125;\n\n\n\n更新用户\n在dao接口中添加方法\n 12345/** * 更新用户 * @param user */void updateUser(User user);\n\n在映射配置文件中添加配置\n 1234&lt;!-- 更新用户--&gt;&lt;update id=\"updateUser\" parameterType=\"com.ydx.domain.User\"&gt;    UPDATE user SET username = #&#123;username&#125;, address = #&#123;address&#125;, sex = #&#123;sex&#125;, birthday = #&#123;birthday&#125; WHERE id = #&#123;id&#125;;&lt;/update&gt;\n\n在测试类中添加测试方法\n 123456789101112131415/** * 测试更新用户操作 */@Testpublic void testUpdateUser() &#123;    User user = new User();    user.setId(51);    user.setUsername(\"杨得轩\");    user.setAddress(\"上海青浦区\");    user.setSex(\"男\");    user.setBirthday(new Date());       //执行更新用户方法    userDao.updateUser(user);&#125;\n\n\n\n删除用户\n在dao接口中添加方法\n 12345/** * 删除用户 * @param userId */void deleteUser(Integer userId);\n\n在映射配置文件中添加配置\n 1234&lt;!-- 删除用户--&gt;&lt;delete id=\"deleteUser\" parameterType=\"Integer\"&gt;    DELETE FROM user WHERE id = #&#123;uid&#125;;&lt;/delete&gt;\n\n在测试类中添加测试方法\n 12345678/** * 测试删除用户操作 */@Testpublic void testDeleteUser() &#123;    //执行删除用户方法    userDao.deleteUser(51);&#125;\n\n\n\n根据id查询用户\n在dao接口中添加方法\n 123456/** * 根据id查询用户 * @param userId * @return */User findById(Integer userId);\n\n在映射配置文件中添加配置\n 1234&lt;!-- 根据id查询用户--&gt;&lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"com.ydx.domain.User\"&gt;    SELECT * FROM user WHERE id = #&#123;uid&#125;;&lt;/select&gt;\n\n在测试类中添加测试方法\n 123456789/** * 测试根据id查询用户操作 */@Testpublic void testFindById() &#123;    //执行根据id查询方法    User user = userDao.findById(48);    System.out.println(user);&#125;\n\n\n\n根据名字模糊查询用户第一种方式\n在dao接口中添加方法\n 123456/** * 根据名字模糊查询用户信息 * @param userName * @return */List&lt;User&gt; findByName(String userName);\n\n在映射配置文件中添加配置\n 1234&lt;!-- 根据名字模糊查询用户--&gt;&lt;select id=\"findByName\" parameterType=\"String\" resultType=\"com.ydx.domain.User\"&gt;    SELECT * FROM user WHERE username LIKE #&#123;name&#125;;&lt;/select&gt;\n\n在测试类中添加测试方法\n 1234567891011/** * 测试名字模糊查询用户操作 */@Testpublic void testFindByName() &#123;    //执行根据名字模糊查询方法    List&lt;User&gt; users = userDao.findByName(\"%王%\");    for (User user: users) &#123;        System.out.println(user);    &#125;&#125;\n\n\n\n第二种方式\n在dao接口中添加方法\n 123456/** * 根据名字模糊查询用户信息，第二种方式（不推荐） * @param userName * @return */List&lt;User&gt; findByName2(String userName);\n\n在映射配置文件中添加配置\n 1234&lt;!-- 根据名字模糊查询用户，另一种传参方式（不推荐）--&gt;&lt;select id=\"findByName2\" parameterType=\"String\" resultType=\"com.ydx.domain.User\"&gt;    SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%';&lt;/select&gt;\n\n在测试类中添加测试方法\n 1234567891011/** * 测试名字模糊查询用户操作，第二种方式（不推荐） */@Testpublic void testFindByName2() &#123;    //执行根据名字模糊查询方法，第二种方式（不推荐）    List&lt;User&gt; users = userDao.findByName2(\"王\");    for (User user: users) &#123;        System.out.println(user);    &#125;&#125;\n\n\n\n#{}与${}的区别\n#{}表示一个占位符号  通过#{}可以实现 preparedStatement 向占位符中设置值，自动进行 Java 类型和 JDBC 类型转换，#{}可以有效防止 SQL 注入；  #{}可以接收简单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，#{}括号中可以是 value 或其它名称。\n\n${}表示拼接 SQL 串  通过${}可以将 parameterType 传入的内容拼接在 SQL 中且不进行 JDBC 类型转换；  ${}可以接收简单类型值或 POJO 属性值，如果 parameterType 传输单个简单类型值，${}括号中只能是 value。 \n\n\n使用聚合查询总用户数\n在dao接口中添加方法\n 12345/** * 使用聚合查询总用户数 * @return */int findTotal();\n\n在映射配置文件中添加配置\n 1234&lt;!-- 使用聚合查询总用户数--&gt;&lt;select id=\"findTotal\" resultType=\"int\"&gt;    SELECT COUNT(id) FROM user;&lt;/select&gt;\n\n在测试类中添加测试方法\n 123456789/** * 测试使用聚合查询总用户数 */@Testpublic void testFindTotal() &#123;    //执行使用聚合查询总用户数    int count = userDao.findTotal();    System.out.println(count);&#125;\n\n\n\n注意事项基本类型和 String 等常用的类我们可以直接写类型名称，也可以使用包名 . 类名的方式，例如：java.lang.String。\n实体类类型，目前我们只能使用全限定类名。\n究其原因，是 MyBaits 在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名，而我们的是实体类并没有注册别名，所以必须写全限定类名。\n\n引用 MyBatis 3.5.3 官方文档\n\n\n这是一些为常见的 Java 类型内建的相应的类型别名。它们都是不区分大小写的，注意对基本类型名称重复采取的特殊命名风格。\n\n\n\n\n别名\n映射的类型\n\n\n\n_byte\nbyte\n\n\n_long\nlong\n\n\n_short\nshort\n\n\n_int\nint\n\n\n_integer\nint\n\n\n_double\ndouble\n\n\n_float\nfloat\n\n\n_boolean\nboolean\n\n\nstring\nString\n\n\nbyte\nByte\n\n\nlong\nLong\n\n\nshort\nShort\n\n\nint\nInteger\n\n\ninteger\nInteger\n\n\ndouble\nDouble\n\n\nfloat\nFloat\n\n\nboolean\nBoolean\n\n\ndate\nDate\n\n\ndecimal\nBigDecimal\n\n\nbigdecimal\nBigDecimal\n\n\nobject\nObject\n\n\nmap\nMap\n\n\nhashmap\nHashMap\n\n\nlist\nList\n\n\narraylist\nArrayList\n\n\ncollection\nCollection\n\n\niterator\nIterator\n\n\n\n\nMyBatis参数parameterType（输入类型）\n输入简单类型\n\n输入POJO对象\n  MyBatis 使用 OGNL 表达式解析对象字段的值，#{}或${}中的值为 POJO 属性名称。\n\n输入POJO包装对象\n  开发中通过 POJO 传递查询条件，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如根据用户名查询用户信息，将用户信息也作为查询条件），这时可以使用包装对象传递输入参数。\n\n编写QueryVo\n 1234567891011121314package com.ydx.domain;public class QueryVo &#123;    private User user;    public User getUser() &#123;        return user;    &#125;    public void setUser(User user) &#123;        this.user = user;    &#125;&#125;\n在dao接口中添加方法\n 123456/** * 根据queryVo中的条件查询用户 * @param vo * @return */List&lt;User&gt; findByVo(QueryVo vo);\n\n在映射配置文件中添加配置\n 1234&lt;!-- 根据queryVo的条件查询用户--&gt;&lt;select id=\"findByVo\" parameterType=\"com.ydx.domain.QueryVo\" resultType=\"com.ydx.domain.User\"&gt;    SELECT * FROM user WHERE username LIKE #&#123;user.username&#125;;&lt;/select&gt;\n\n在测试类中添加测试方法\n 12345678910111213141516/** * 测试根据queryVo中的条件查询用户 */@Testpublic void testFindByVo() &#123;    QueryVo vo = new QueryVo();    User user = new User();    user.setUsername(\"%王%\");    vo.setUser(user);           //执行根据queryVo中的条件查询用户    List&lt;User&gt; users = userDao.findByVo(vo);    for (User u: users) &#123;        System.out.println(u);    &#125;&#125;\n\n\n\n\n\nreturnType（输出类型）\n输出简单类型\n\n输出POJO对象\n\n输出POJO列表\n\n\nresultMap（结果类型）","color":"#EBF8FF","plink":"http://alpac.top/articles/21570/"},{"title":"MyBatis框架入门二. MyBatis框架入门","date":"2019-11-16T07:24:43.000Z","date_formatted":{"ll":"2019年11月16日","L":"2019/11/16","MM-DD":"11-16"},"updated":"2019-12-20T08:17:32.583Z","content":"MyBatis框架入门二. MyBatis框架入门MyBatis概述MyBatis是用Java编写的持久型框架，封装了JDBC操作的很多细节，使开发者只需要关注SQL语句本身，无需关注注册驱动、创建连接等繁杂过程；\nMyBatis使用ORM思想实现了结果集的封装。\nORMObeject Relational Mapping对象关系映射：\n把数据库表和实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表\nMyBatis入门示例MyBatis环境搭建\n创建Maven工程并导入坐标\n pom.xml文件如下配置：\n1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.ydx&lt;/groupId&gt;    &lt;artifactId&gt;MyBatis_test&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;!-- 打包方式--&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;!-- 依赖列表--&gt;    &lt;dependencies&gt;        &lt;!-- MyBatis--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- MySQL--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.15&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- log4j--&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- JUnit--&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n创建实体类和dao的接口，如实体类User，dao接口UserDao\n实体类中的属性与数据库表中字段对应，示例如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.ydx.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123;    private Integer id;    private String username;    private Date birthday;    private String sex;    private String address;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public Date getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(Date birthday) &#123;        this.birthday = birthday;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;    @Override    public String toString() &#123;        return \"User&#123;\" +                \"id=\" + id +                \", username='\" + username + '\\'' +                \", birthday=\" + birthday +                \", sex='\" + sex + '\\'' +                \", address='\" + address + '\\'' +                '&#125;';    &#125;&#125;\n\ndao的接口示例如下：\n1234567891011121314151617package com.ydx.dao;import com.ydx.domain.User;import java.util.List;/** * 用户持久层接口 */public interface UserDao &#123;    /**     * 查询所有操作     * @return     */    List&lt;User&gt; findAll();&#125;\n\n创建MyBatis的主配置文件：SqlMapConfig.xml\n 主配置文件SqlMapConfig.xml配置示例如下：\n123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- MyBatis的主配置文件--&gt;&lt;configuration&gt;    &lt;!-- 配置环境--&gt;    &lt;environments default=\"mysql\"&gt;        &lt;!-- 配置MySQL的环境--&gt;        &lt;environment id=\"mysql\"&gt;            &lt;!-- 配置事务类型--&gt;            &lt;transactionManager type=\"JDBC\"/&gt;            &lt;!-- 配置数据源（连接池）--&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;!-- 配置连接数据库的4个基本信息。                     有了它就能创建Connection对象。                --&gt;                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt;                &lt;property name=\"username\" value=\"用户名\"/&gt;                &lt;property name=\"password\" value=\"密码\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件；         如果使用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名。         有了它就有了映射配置信息。    --&gt;    &lt;mappers&gt;        &lt;mapper resource=\"com/ydx/dao/UserDao.xml\"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n\n创建映射配置文件：如UserDao.xml\n 映射配置文件配置如下：\n12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper       PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"       \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace中要写全限定类名--&gt;&lt;mapper namespace=\"com.ydx.dao.UserDao\"&gt;   &lt;!-- 配置查询所有，id要写方法名称, resultType要写返回类型。        有了它就有了执行的SQL语句，就可以获取PrepaareSatement   --&gt;   &lt;select id=\"findAll\" resultType=\"com.ydx.domain.User\"&gt;       SELECT * FROM user;   &lt;/select&gt;&lt;/mapper&gt;\n\n\n\n\n注意：\n\n创建UserDao.xml和UserDao.Java时名称是为了和我们之前的只是保持一致。在MyBatis中它把持久层的操作接口名称和映射文件也叫做Mapper，所以UserDao.xml和UserMapper是一样的\n\n在IDEA中创建目录的时候，它和包是不一样的，包在创建时com.ydx.dao是三级结构，而目录在创建时com.ydx.dao是一级目录\n\nMyBatis的映射配置文件位置必须和dao接口的包结构相同\n\n映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名\n\n映射配置文件的操作配置，id属性的取值必须是dao接口的方法名\n  当我们遵从了第3、4、5点后，我们之后在开发中就无需再写dao的实现类\n\n\n以上读取配置文件用到了dom4j解析xml技术。\nMyBatis的入门示例MyBatis基于xml的入门示例\n读取配置文件\n 1InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n读取路径时使用相对路径与绝对路径都会存在问题，在实际开发中应该使用以下两种方法：\n\n使用类加载器，他只能读取类路径的配置文件；\n使用ServletContext对象的getRealPath()，它能得到当前应用部署的绝对路径。\n\n\n创建SqlSessionFactory工厂\n 12SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(in);\n创建工厂时MyBatis使用了构建者模式，构建者模式优点：把对象的创建细节隐藏，是使用者直接调用方法即可拿到对象。\n\n创建SqlSession对象\n 1SqlSession session = factory.openSession();\n生产SqlSession使用了工厂模式，工厂模式优点：解耦（降低类之间的依赖关系）。\n\n创建dao接口的代理对象\n 1UserDao userdao = session.getMapper(UserDao.class);\n创建dao接口实现类使用了代理模式，代理模式优点：不修改源码的基础上对已有方法增强。\n\n执行dao中的方法\n 1234List&lt;User&gt; users = userdao.findAll();for (User user : users) &#123;    System.out.println(user);&#125;\n释放资源\n 12session.close();in.close();\n\n\n\n完整代码如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041package com.ydx.test;import com.ydx.dao.UserDao;import com.ydx.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;/** * MyBatis示例 */public class MyBatisTest &#123;    /**     * MyBatis示例     */    public static void main(String[] args) throws IOException &#123;        //读取配置文件        InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\");        //创建SqlSessionFactiory工厂        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();        SqlSessionFactory factory = builder.build(in);        //使用工厂生产SqlSession对象        SqlSession session = factory.openSession();        //使用SqlSession创建dao接口的代理对象        UserDao userDao = session.getMapper(UserDao.class);        //使用代理对象执行方法        List&lt;User&gt; users = userDao.findAll();        for (User user : users) &#123;            System.out.println(user);        &#125;        //释放资源        session.close();        in.close();    &#125;&#125;\n\n注意：\n\n不要忘记在映射配置文件中告知MyBatis要封装到那个实体类中，配置的方式：指定实体类的全限定类名\n\nMyBatis基于注解的入门示例把UserDao.xml移除，在dao接口的方法上使用@Select注解，并指定SQL语，同时需要在SqlMapConfig.xml中使用mapper配置时，使用class属性指定dao接口的全限定类名。\ndao接口中方法代码如下：\n123456789public interface UserDao &#123;    /**     * 查询所有操作     * @return     */    @Select(\"SELECT * FROM user;\")    List&lt;User&gt; findAll();&#125;\n\n\nSqlMapConfig.xml中配置如下：\n123456&lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件；    如果使用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名--&gt;&lt;mappers&gt;    &lt;mapper class=\"com.ydx.dao.UserDao\"/&gt;&lt;/mappers&gt;\n\nMyBatis支持dao实现类MyBatis也是支持写dao实现类的，但在实际开发中，为了简便，不管使用xml还是注解类型，都是采用不写dao实现类的方式。\n","color":"#EBF8FF","plink":"http://alpac.top/articles/39266/"},{"title":"MyBatis框架入门一. 框架概述","date":"2019-11-16T07:05:20.000Z","date_formatted":{"ll":"2019年11月16日","L":"2019/11/16","MM-DD":"11-16"},"updated":"2019-12-20T08:17:23.901Z","content":"MyBatis框架入门一. 框架概述什么是框架？框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。 \n简而言之，框架是软件开发中的一套解决方案，不同框架解决不通问题。\n使用框架的好处：框架封装了很多细节，使开发者可使用极简的方式实现功能，提高开发效率。\nMVC三层架构\n表现层（User Interface layer, UIL）：展示数据\n业务层（Business Logic Layer, BLL）：处理业务需求\n持久层（Data access layer, DAL）：数据库交互\n\n\n持久层技术解决方案JDBC技术\nConnection\nPreparedStatement\nResultSet\n\nSpring的JdbcTemplateSpring中对JDBC的简单封装\nApache的DBUtilsApache中对JDBC的简单封装\n以上这些都不是框架：\nJDBC是规范，Spring的JdbcTemplate和Apache的DBUtils都只是工具类\nJDBC代码示例如下代码使用了 JDBC 的原始方法（未经封装）实现查询数据库表记录的操作。 \n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) &#123;    Connection connection = null;    PreparedStatement preparedStatement = null;    ResultSet resultSet = null;    try &#123;        //加载数据库驱动        Class.forName(\"com.mysql.cj.jdbc.Driver\");        //通过驱动管理类获取数据库链接        String url = \"jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;characterEncoding=utf-8\";        String username = \"用户名\";        String password = \"密码\";        connection = DriverManager.getConnection(url, username, password);        //定义SQL语句，?表示占位符        String sql = \"select * from user where username = ?\";        //获取预处理statement        preparedStatement = connection.prepareStatement(sql);        //设置参数，第一个参数为SQL语句中参数的序号（从1开始），第二个参数为设置的参数值        preparedStatement.setString(1, \"杨得轩\");        //向数据库发出SQL执行查询，查询出结果集        resultSet = preparedStatement.executeQuery();        //遍历查询结果集        while (resultSet.next()) &#123;            System.out.println(resultSet.getString(\"id\") + \"\\t\" + resultSet.getString(\"username\"));        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();    &#125; finally &#123;        //释放资源        if (resultSet != null) &#123;            try &#123;                resultSet.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (preparedStatement != null) &#123;            try &#123;                preparedStatement.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (connection != null) &#123;            try &#123;                connection.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\n原始JDBC缺点\n数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。\nSQL 语句在代码中硬编码，造成代码不易维护，实际应用 SQL 变化的可能较大，SQL 变动需要改变 Java 代码。 \n使用 preparedStatement 向占有位符号传参数存在硬编码，因为 SQL 语句的 where 条件不一定，可能多也可能少，修改 SQL 还要修改代码，系统不易维护。\n对结果集解析存在硬编码(查询列名)，SQL变化导致解析代码变化，系统不易维护，如果能将数据库记 录封装成 POJO 对象解析比较方便。\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/43834/"},{"title":"Hello World","date":"2019-10-30T04:24:15.947Z","date_formatted":{"ll":"2019年10月30日","L":"2019/10/30","MM-DD":"10-30"},"updated":"2019-12-03T11:04:16.062Z","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","plink":"http://alpac.top/articles/16107/"},{"title":"Java208道经典面试题目七. 异常","date":"2019-09-27T04:03:30.000Z","date_formatted":{"ll":"2019年9月27日","L":"2019/09/27","MM-DD":"09-27"},"updated":"2019-12-03T11:04:16.052Z","content":"Java208道经典面试题目七. 异常74. throw 和 throws 的区别？throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。\n75. final、finally、finalize 有什么区别？\nfinal可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。\nfinally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\nfinalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 \n\n76. try-catch-finally 中哪个部分可以省略？catch 可以省略。\n原因：\n更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。\n理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。\n至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。\n77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？会执行，在 return 前执行。\n代码示例1：\n12345678910111213141516171819202122232425public class FinallyDemo2 &#123;    public static void main(String[] args) &#123;        System.out.println(getInt());    &#125;    public static int getInt() &#123;        int a = 10;        try &#123;            System.out.println(a / 0);            a = 20;        &#125; catch (ArithmeticException e) &#123;            a = 30;            return a;            /*             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30             */        &#125; finally &#123;            a = 40;        &#125;//      return a;    &#125;&#125;\n\n执行结果：30\n代码示例2：\n1234567891011121314151617181920212223242526public class FinallyDemo2 &#123;    public static void main(String[] args) &#123;        System.out.println(getInt());    &#125;    public static int getInt() &#123;        int a = 10;        try &#123;            System.out.println(a / 0);            a = 20;        &#125; catch (ArithmeticException e) &#123;            a = 30;            return a;            /*             * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了             * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40             * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30             */        &#125; finally &#123;            a = 40;            return a; //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40        &#125;//      return a;    &#125;&#125;\n\n执行结果：40\n78. 常见的异常类有哪些？\nNullPointerException：当应用程序试图访问空对象时，则抛出该异常。\nSQLException：提供关于数据库访问错误或其他错误信息的异常。\nIndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 \nNumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\nFileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。\nIOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。\nClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。\nArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。\nIllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。\nArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 \nNegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。\nNoSuchMethodException：无法找到某一特定方法时，抛出该异常。\nSecurityException：由安全管理器抛出的异常，指示存在安全侵犯。\nUnsupportedOperationException：当不支持请求的操作时，抛出该异常。\nRuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/14151/"},{"title":"Java208道经典面试题目六. Java Web","date":"2019-09-27T03:47:23.000Z","date_formatted":{"ll":"2019年9月27日","L":"2019/09/27","MM-DD":"09-27"},"updated":"2019-12-03T11:04:16.078Z","content":"Java208道经典面试题目六. Java Web64. jsp 和 servlet 有什么区别？\njsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）\njsp更擅长表现于页面显示，servlet更擅长于逻辑控制。\nServlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。\nJsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。\n\n65. jsp 有哪些内置对象？作用分别是什么？\nrequest：封装客户端的请求，其中包含来自GET或POST请求的参数；\nresponse：封装服务器对客户端的响应；\npageContext：通过该对象可以获取其他对象；\nsession：封装用户会话的对象；\napplication：封装服务器运行环境的对象；\nout：输出服务器响应的输出流对象；\nconfig：Web应用的配置对象；\npage：JSP页面本身（相当于Java程序中的this）；\nexception：封装页面抛出异常的对象。\n\n66. 说一下 jsp 的 4 种作用域？JSP中的四种作用域包括page、request、session和application，具体来说：\n\npage代表与一个页面相关的对象和属性。\nrequest代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。\nsession代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。\napplication代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。\n\n67. session 和 cookie 有什么区别？\n由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。\n思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。\nCookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。\n\n68. 说一下 session 的工作原理？其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。\n69. 如果客户端禁用 cookie ， session 还能用吗？Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。\n假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：\n\n手动通过URL传值、隐藏表单传递Session ID。\n用文件、数据库等形式保存Session ID，在跨页过程中手动调用。\n\n70. Spring MVC 和 Struts 的区别是什么？\n拦截机制的不同\n\nStruts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。\nSpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。\nStruts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。\n\n底层框架的不同　　Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。\n\n性能方面\n\n\nStruts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。\n\n配置方面\n\nSpring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。\n71. 如何避免 sql 注入？\nPreparedStatement（简单又有效的方法）\n使用正则表达式过滤传入的参数\n字符串过滤\nJSP中调用该函数检查是否包函非法字符\nJSP页面判断代码\n\n72. 什么是 XSS 攻击，如何避免？XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。\n如何避免：对输入(和URL参数)进行过滤，对输出进行编码。\n73. 什么是 CSRF 攻击，如何避免？CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。\n如何避免：\n\n验证 HTTP Referer 字段\n\nHTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。\n\n使用验证码\n\n关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。\n\n在请求地址中添加token并验证\n\nCSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。而对于 POST 请求来说，要在 form 的最后加上 ，这样就把token以参数的形式加入请求了。\n\n在HTTP 头中自定义属性并验证\n\n这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。\n","color":"#EBF8FF","plink":"http://alpac.top/articles/28500/"},{"title":"Java208道经典面试题目五. 对象拷贝","date":"2019-09-27T03:40:08.000Z","date_formatted":{"ll":"2019年9月27日","L":"2019/09/27","MM-DD":"09-27"},"updated":"2019-12-03T11:04:16.054Z","content":"Java208道经典面试题目五. 对象拷贝61. 为什么要使用克隆？想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。\n62. 如何实现对象克隆？有两种方式：\n1). 实现Cloneable接口并重写Object类中的clone()方法；\n2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：\n123456789101112131415161718192021222324252627282930import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class MyUtil &#123;    private MyUtil() &#123;        throw new AssertionError();    &#125;    @SuppressWarnings(\"unchecked\")    public static &lt;T extends Serializable&gt; T clone(T obj)                                   throws Exception &#123;        ByteArrayOutputStream bout = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(bout);        oos.writeObject(obj);        ByteArrayInputStream bin =                     new ByteArrayInputStream(bout.toByteArray());        ObjectInputStream ois = new ObjectInputStream(bin);        return (T) ois.readObject();        // 说明：调用ByteArrayInputStream        //或ByteArrayOutputStream对象的close方法没有任何意义        // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，        //这一点不同于对外部资源（如文件流）的释放    &#125;&#125;\n\n下面是测试代码：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.Serializable;/** * 人类 * @author nnngu * */class Person implements Serializable &#123;    private static final long serialVersionUID                               = -9102017020286042305L;    private String name;    // 姓名    private int age;        // 年龄    private Car car;        // 座驾    public Person(String name, int age, Car car) &#123;        this.name = name;        this.age = age;        this.car = car;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public Car getCar() &#123;        return car;    &#125;    public void setCar(Car car) &#123;        this.car = car;    &#125;    @Override    public String toString() &#123;        return \"Person [name=\" + name + \",                       age=\" + age + \", car=\" + car + \"]\";    &#125;&#125;\n\n12345678910111213141516171819202122232425262728293031323334353637383940/** * 小汽车类 * @author nnngu * */class Car implements Serializable &#123;    private static final long serialVersionUID                                 = -5713945027627603702L;    private String brand;       // 品牌    private int maxSpeed;       // 最高时速    public Car(String brand, int maxSpeed) &#123;        this.brand = brand;        this.maxSpeed = maxSpeed;    &#125;    public String getBrand() &#123;        return brand;    &#125;    public void setBrand(String brand) &#123;        this.brand = brand;    &#125;    public int getMaxSpeed() &#123;        return maxSpeed;    &#125;    public void setMaxSpeed(int maxSpeed) &#123;        this.maxSpeed = maxSpeed;    &#125;    @Override    public String toString() &#123;        return \"Car [brand=\" + brand + \",                       maxSpeed=\" + maxSpeed + \"]\";    &#125;&#125;\n\n1234567891011121314151617class CloneTest &#123;    public static void main(String[] args) &#123;        try &#123;            Person p1 = new Person(\"郭靖\", 33,                               new Car(\"Benz\", 300));            Person p2 = MyUtil.clone(p1);   // 深度克隆            p2.getCar().setBrand(\"BYD\");            // 修改克隆的Person对象p2关联的汽车对象的品牌属性            // 原来的Person对象p1关联的汽车不会受到任何影响            // 因为在克隆Person对象时其关联的汽车对象也被克隆了            System.out.println(p1);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。\n63. 深拷贝和浅拷贝区别是什么？\n浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）\n深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/18869/"},{"title":"Java208道经典面试题目四. 反射","date":"2019-09-26T15:54:30.000Z","date_formatted":{"ll":"2019年9月26日","L":"2019/09/26","MM-DD":"09-26"},"updated":"2019-12-03T11:04:16.055Z","content":"Java208道经典面试题目四. 反射57. 什么是反射？反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力\nJava反射：在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法。\nJava反射机制主要提供了以下功能：\n\n在运行时判断任意一个对象所属的类。\n在运行时构造任意一个类的对象。\n在运行时判断任意一个类所具有的成员变量和方法。\n在运行时调用任意一个对象的方法。 \n\n58. 什么是 java 序列化？什么情况下需要序列化？简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。\n什么情况下需要序列化：\n\n当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；\n当你想用套接字在网络上传送对象的时候；\n当你想通过RMI传输对象的时候；\n\n59. 动态代理是什么？有哪些应用？动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。\n动态代理的应用：\n\nSpring的AOP\n加事务\n加权限\n加日志\n\n60. 怎么实现动态代理？首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。\n","color":"#EBF8FF","plink":"http://alpac.top/articles/28440/"},{"title":"Java208道经典面试题目三. 多线程","date":"2019-09-26T13:35:33.000Z","date_formatted":{"ll":"2019年9月26日","L":"2019/09/26","MM-DD":"09-26"},"updated":"2019-12-03T11:04:16.084Z","content":"Java208道经典面试题目三. 多线程35. 并行和并发有什么区别？并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。\n\n并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。\n\n\n并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。\n并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。\n并行是在一台处理器上“同时”处理多个任务，并发是在多台处理器上同时处理多个任务。如hadoop分布式集群。\n\n所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。\n36. 线程和进程的区别？\n进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。\n每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。\n在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。\n系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。\n没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。\n\n37. 守护线程是什么？守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。\n38. 创建线程有哪几种方式？①. 继承Thread类创建线程类\n\n定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把 run() 方法称为执行体。\n创建Thread子类的实例，即创建了线程对象。\n调用线程对象的 start() 方法来启动该线程。\n\n②. 通过Runnable接口创建线程类\n\n定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。\n创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。\n调用线程对象的 start() 方法来启动该线程。\n\n③. 通过Callable和Future创建线程\n\n创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。\n创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。\n使用FutureTask对象作为Thread对象的target创建并启动新线程。\n调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。\n\n39. 说一下 runnable 和 callable 有什么区别？有点深的问题了，也看出一个Java程序员学习知识的广度。\n\nRunnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；\nCallable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。\n\n40. 线程有哪些状态？线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。\n\n创建状态：在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。\n就绪状态：当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。\n运行状态：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。\n阻塞状态：线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。\n死亡状态：如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 　\n\n\n41. sleep() 和 wait() 有什么区别？sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。\nwait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。\n42. notify() 和 notifyAll() 有什么区别？\n如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\n当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。\n优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。\n\n43. 线程的 run() 和 start()有什么区别？每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。\nstart()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。\nrun()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。\n44. 创建线程池有哪几种方式？①. newFixedThreadPool(int nThreads)\n创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。\n②. newCachedThreadPool()\n创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。\n③. newSingleThreadExecutor()\n这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。\n④. newScheduledThreadPool(int corePoolSize)\n创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。\n45. 线程池都有哪些状态？线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。\n线程池各个状态切换框架图：\n\n46. 线程池中 submit() 和 execute() 方法有什么区别？\n接收的参数不一样\nsubmit有返回值，而execute没有\nsubmit方便Exception处理\n\n47. 在 java 程序中怎么保证多线程的运行安全？线程安全在三个方面体现：\n\n原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；\n可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；\n有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。\n\n48. 多线程锁的升级原理是什么？在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。\n锁升级的图示过程： \n\n49. 什么是死锁？死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。\n50. 怎么防止死锁？死锁的四个必要条件：\n\n互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源\n请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放\n不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放\n环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系\n\n这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。\n理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。\n所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。\n此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。\n51. ThreadLocal 是什么？有哪些使用场景？线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。\n52.说一下 synchronized 底层实现原理？synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。\nJava中每一个对象都可以作为锁，这是synchronized实现同步的基础：\n\n普通同步方法，锁是当前实例对象\n静态同步方法，锁是当前类的class对象\n同步方法块，锁是括号里面的对象\n\n53. synchronized 和 volatile 的区别是什么？\nvolatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\nvolatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\nvolatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。\nvolatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。\nvolatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。\n\n54. synchronized 和 Lock 有什么区别？\n首先synchronized是java内置关键字，在jvm层面，Lock是个java类；\nsynchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\nsynchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\nsynchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；\nLock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n\n55. synchronized 和 ReentrantLock 区别是什么？synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： \n\nReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 \nReentrantLock可以获取各种锁的信息\nReentrantLock可以灵活地实现多路通知 \n\n另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。\n56. 说一下 atomic 的原理？Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。\nAtomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。\n","color":"#EBF8FF","plink":"http://alpac.top/articles/20688/"},{"title":"Java208道经典面试题目二. 容器","date":"2019-09-16T02:49:00.000Z","date_formatted":{"ll":"2019年9月16日","L":"2019/09/16","MM-DD":"09-16"},"updated":"2019-12-03T11:04:16.053Z","content":"Java208道经典面试题目二. 容器18. Java 容器都有哪些？\n19. Collection 和 Collections 有什么区别？\njava.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。\nCollections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。\n\n20. List、Set、Map 之间的区别是什么？\n\n\n比较\nList\nSet\nMap\n\n\n\n继承接口\nCollection\nCollection\n\n\n\n常见实现类\nAbstractList（其常用子类有ArrayList、LinkedList、Vector）\nAbstractSet（其常用子类有HashSet、LinkedHashSet、TreeSet）\nHashMap、HashTable\n\n\n常见方法\nadd()、remove()、clear()、get()、contains()、size()\nadd()、remove()、clear()、contains()、size()\nput()、get()、remove()、clear()、containsKey()、containsValue()、keySet()、values()、size()\n\n\n元素\n可重复\n不可重复（用equals()判断）\n不可重复\n\n\n顺序\n有序\n无序（实际上由HashCode决定）\n\n\n\n线程安全\nVector线程安全\n\nHashTable线程安全\n\n\n21. HashMap 和 Hashtable 有什么区别？\nhashMap去掉了HashTable 的contains方法，但是加上了containsValue()和containsKey()方法。\nhashTable同步的，而HashMap是非同步的，效率上比hashTable要高。\nhashMap允许空键值，而hashTable不允许。\n\n22. 如何决定使用 HashMap 还是 TreeMap？对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。\n23. 说一下 HashMap 的实现原理？HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 \nHashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。\n当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。\n需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)\n24. 说一下 HashSet 的实现原理？\nHashSet底层由HashMap实现  \nHashSet的值存放于HashMap的key上  \nHashMap的value统一为PRESENT\n\n25. ArrayList 和 LinkedList 的区别是什么？最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。\n26. 如何实现数组和 List 之间的转换？\nList转换成为数组：调用ArrayList的toArray方法。\n数组转换成为List：调用Arrays的asList方法。\n\n27. ArrayList 和 Vector 的区别是什么？\nVector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 \nArrayList比Vector快，它因为有同步，不会过载。 \nArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。\n\n28. Array 和 ArrayList 有何区别？\nArray可以容纳基本类型和对象，而ArrayList只能容纳对象。 \nArray是指定大小的，而ArrayList大小是固定的。 \nArray没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。\n\n29. 在 Queue 中 poll()和 remove()有什么区别？poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。\n30. 哪些集合类是线程安全的？\nvector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。\nstatck：堆栈类，先进后出。\nhashtable：就比hashmap多了个线程安全。\nenumeration：枚举，相当于迭代器。\n\n31. 迭代器 Iterator 是什么？迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。\n32. Iterator 怎么使用？有什么特点？Java中的Iterator功能比较简单，并且只能单向移动：\n\n使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。\n使用next()获得序列中的下一个元素。\n使用hasNext()检查序列中是否还有元素。\n使用remove()将迭代器新返回的元素删除。\n\nIterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。\n33. Iterator 和 ListIterator 有什么区别？\nIterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 \nIterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 \nListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。\n\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/46603/"},{"title":"Java208道经典面试题目一. Java基础","date":"2019-09-15T09:17:18.000Z","date_formatted":{"ll":"2019年9月15日","L":"2019/09/15","MM-DD":"09-15"},"updated":"2019-12-03T11:04:16.076Z","content":"Java208道经典面试题目一. Java基础1. JDK 和 JRE 有什么区别？\nJDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。\nJRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。\n\n具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。\n2. == 和 equals 的区别是什么？==解读\n对于基本类型和引用类型 == 的作用效果是不同的，如下所示：\n\n基本类型：比较的是值是否相同；\n引用类型：比较的是引用是否相同；\n\n代码示例：\n1234567String x = \"string\";String y = \"string\";String z = new String(\"string\");System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true\n\n代码解读：\n因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。\nequals 解读\nequals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。\n首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：\n12345678910111213141516171819class Cat &#123;    public Cat(String name) &#123;        this.name = name;    &#125;    private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;Cat c1 = new Cat(\"王磊\");Cat c2 = new Cat(\"王磊\");System.out.println(c1.equals(c2)); // false\n\n输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：\n123public boolean equals(Object obj) &#123;    return (this == obj);&#125;\n\n原来 equals 本质上就是 ==。\n那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：\n123String s1 = new String(\"老王\");String s2 = new String(\"老王\");System.out.println(s1.equals(s2)); // true\n\n同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：\n123456789101112131415161718192021public boolean equals(Object anObject) &#123;    if (this == anObject) &#123;        return true;    &#125;    if (anObject instanceof String) &#123;        String anotherString = (String)anObject;        int n = value.length;        if (n == anotherString.value.length) &#123;            char v1[] = value;            char v2[] = anotherString.value;            int i = 0;            while (n-- != 0) &#123;                if (v1[i] != v2[i])                    return false;                i++;            &#125;            return true;        &#125;    &#125;    return false;&#125;\n\n原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。\n总结：\n== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？不对，两个对象的 hashCode()相同，equals()不一定 true。\n代码示例：\n12345String str1 = \"通话\";String str2 = \"重地\";System.out.println(String.format(\"str1：%d | str2：%d\",                      str1.hashCode(),str2.hashCode()));System.out.println(str1.equals(str2));\n\n执行的结果：\n12str1：1179395 | str2：1179395false\n\n代码解读：\n很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。\n4. final 在 java 中有什么作用？\nfinal 修饰的类叫最终类，该类不能被继承。\nfinal 修饰的方法不能被重写。\nfinal 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n5. java 中的 Math.round(-1.5) 等于多少？等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。\n6. String 属于基础的数据类型吗？String 不属于基础类型，基础类型有 8 种：\nbyte、boolean、char、short、int、float、long、double，而 String 属于对象。\n7. java 中操作字符串都有哪些类？它们之间有什么区别？操作字符串的类有：String、StringBuffer、StringBuilder。\nString 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n8. String str=”i”与 String str=new String(“i”)一样吗？不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。\n9. 如何将字符串反转？使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n示例代码：\n12345678// StringBuffer reverseStringBuffer stringBuffer = new StringBuffer();stringBuffer.append(\"abcdefg\");System.out.println(stringBuffer.reverse()); // gfedcba// StringBuilder reverseStringBuilder stringBuilder = new StringBuilder();stringBuilder.append(\"abcdefg\");System.out.println(stringBuilder.reverse()); // gfedcba\n\n10. String 类的常用方法都有那些？\nindexOf()：返回指定字符的索引。\ncharAt()：返回指定索引处的字符。\nreplace()：字符串替换。\ntrim()：去除字符串两端空白。\nsplit()：分割字符串，返回一个分割后的字符串数组。\ngetBytes()：返回字符串的 byte 类型数组。\nlength()：返回字符串长度。\ntoLowerCase()：将字符串转成小写字母。\ntoUpperCase()：将字符串转成大写字符。\nsubstring()：截取字符串。\nequals()：字符串比较。\n\n11. 抽象类必须要有抽象方法吗？不需要，抽象类不一定非要有抽象方法。\n示例代码：\n12345abstract class Cat &#123;    public static void sayHi() &#123;        System.out.println(\"hi~\");    &#125;&#125;\n\n上面代码，抽象类并没有抽象方法但完全可以正常运行。\n12. 普通类和抽象类有哪些区别？\n普通类不能包含抽象方法，抽象类可以包含抽象方法。\n抽象类不能直接实例化，普通类可以直接实例化。\n\n13. 抽象类能使用 final 修饰吗？不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：\n\n14. 接口和抽象类有什么区别？\n实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n构造函数：抽象类可以有构造函数；接口不能有。\nmain 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。  \n实现数量：类可以实现很多个接口；但是只能继承一个抽象类。 \n访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n15. java 中 IO 流分为几种？按功能来分：输入流（input）、输出流（output）。\n按类型来分：字节流和字符流。\n字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。\n16. BIO、NIO、AIO 有什么区别？\nBIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 \nNIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\nAIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n17. Files的常用方法都有哪些？\nFiles.exists()：检测文件路径是否存在。\nFiles.createFile()：创建文件。\nFiles.createDirectory()：创建文件夹。\nFiles.delete()：删除一个文件或目录。\nFiles.copy()：复制文件。\nFiles.move()：移动文件。\nFiles.size()：查看文件个数。\nFiles.read()：读取文件。\nFiles.write()：写入文件。\n\n\n","color":"#EBF8FF","plink":"http://alpac.top/articles/46157/"},{"title":"杨得轩个人简历","date":"2019-09-15T12:44:29.000Z","date_formatted":{"ll":"2019年9月15日","L":"2019/09/15","MM-DD":"09-15"},"updated":"2019-12-03T10:19:51.547Z","content":"联系方式\n手机：\n184-6812-7192（云南）\n152-4190-4600（辽宁）\n\n\nEmail：\ny850189787@gmail.com\n\n\nQQ/微信号：\n850189787\n\n\n\n个人信息\n杨得轩/男/满族/1997\n\n本科/云南民族大学/软件工程\n\n籍贯：辽宁大连\n\n现居地：上海\n\n技术博客：https://alpac.top\n\nGithub：https://github.com/YoungTakhin\n\n期望职位：PHP &gt; Java &gt; 前端 &gt; Python\n\n期望城市：深圳/广州\n\n\n\n工作经历上海汉得信息技术股份有限公司 （2019.11 - 至今）\nJava后端\n\n在此次工作中我主要负责基于内部框架的后端业务逻辑编码，基于SpringBoot与SpringCloud的微服务开发，对SSM框架与SpringBoot框架有了进一步的了解。\n昆明财通科技有限公司 （ 2019.03 – 2019.05 ）\n软件实施运维\n\n在此次工作中我主要负责财务软件（云南民族大学全面预算管理系统）在用户单位的运行维护及其需求处理，解决用户单位的在软件使用过程中出现的各种问题，在必要时操作 ORACLE 数据库，熟悉了 PL/SQL，获得了用户的一致好评。\n云南民族大学信息与网络中心 （ 2018.09 – 2019.03 ）\n网络维护 \n\n主要负责云南民族大学校园网的维护与网络故障报修等，了解了 H3C 与 Cisco 体系路由器和交换机的基本配置以及常用网络协议，在此工作中我善于运用专业知识发现并排除问题，获得了本校师生的一致好评。\n项目和作品项目经验\n智慧叫车系统（商业项目）：\n我在本项目中担任前端开发的角色，我主要负责本项目中 LED 大屏软件(应用于旅游景区广告牌的 Web)的开发，基于 Vue CLI + Vue-router 与 Bootstrap 并借助一些项目管理软件进行前后端分离开发，与后端数据接口（PHP+ThinkPHP）对接，在此项目中我学习了商业级别的代码规范，进一步了解了前端开发以及 Vue 前端框架，商业项目。\n\n“快交”作业提交系统 （个人项目）：\n一款针对于教师和学生的作业提交系统，后端基于 PHP + MySQL 并运用 Laravel MVC 框架，前端基于 BootStrap 样式框架开发，在校课程项目。\n\n在线考试系统 （团队项目）：\n一款适用于学生在线答题的系统，快速迭代开发，基于 JavaBean + JSP + Servlet 的 MVC设计模式，并使用了 BootStrap 前端框架，采用 Github 来进行版本控制，我主要负责部分业务逻辑层和视图的编写，在校课程项目。\n\n民大在线书店（个人项目）：\n一款在线书店，基于 JavaBean + JSP + Servlet 的 MVC 设计模式并使用了 BootStrap 前端框架进行开发，在校课程项目。\n\n连连看游戏（团队项目）：\n一款基于 Cocos2d-Python 引擎的连连看小游戏，在此项目中，我主要负责连连看后端核心算法的编写，涉及到图的算法，了解了游戏引擎的基础应用，实训项目。\n\n基于模式识别的纸质书籍声控朗读神器（团队项目）：\n一款能够扫面纸质书籍并将其文字提取、朗读的嵌入式设备，在此项目中承担了项目负责人的角色，并兼具前后端开发角色，基于树莓派 3B+与 Python 编程语言，使用了百度云 API，竞赛项目。\n\n\n技能清单\nWeb 前端：HTML、CSS、JavaScript、微信小程序\nWeb 后端：JavaEE、PHP\nWeb 框架：\nPHP：Laravel\nJava：Spring、SpringMVC、MyBatis、SpringBoot\nJavaScript：JQuery、Vue.js\nCSS：BootStrap\n\n\n其他编程语言：Java、Python、C\n机器学习：XGBoost、Scikit-learn、Keras、Tensorflow\n数据处理：Pandas\n游戏引擎：Cocos2d(Python)\n数据库相关：MySQL、SQL Server、ORACLE、Redis\n工具：Git、Markdown、Office\n\n\n竞赛经历\n第十二届大学生创新创业项目国家级立项（国家级）\n“认证杯”数学中国数学建模网络挑战赛第二阶段三等奖（国家级）\n2019 CCF CCSP 分赛区竞赛优秀奖（区域级）\nPAT 团体程序设计天梯赛云南省一等奖（省级）\n第五届中国“互联网+”大学生创新创业大赛云南省银奖（省级）\n第一届“华为”程序设计大赛三等奖（校级）\n“汉柏杯”计算机设计大赛校级三等奖（校级）\n科技嘉年华暨计算机文化节“C 语言知识竞赛”优秀奖（校级）\n全国大学生数学建模竞赛云南民族大学选拔赛二等奖（校级）\n第四届中国“互联网+”大学生创新创业大赛数学与计算机科学学院二等奖（学院级）\n\n获奖经历\n普通高校 2018-2019 年学年度省政府奖学金\n云南民族大学 2018-2019 年三好学生奖学金\n云南民族大学 2017 年度学生进步奖学金\n\n技能证书\n第十六次中国计算机学会计算机软件能力认证（CCF CSP）计算机软件能力认证证书（Java 200 分，排名前 10.94%）\n普通话水平测试等级证书二级乙等\n\n培训经历\n北京千锋互联科技有限公司 Python 实训课\n本次实训由千锋互联资深讲师教授，除了学习了 Python 的基础知识外，还学习到了 Python 爬虫，Django Web 框架和 Cocos2d 游戏引擎，并能将学习的理论知识运用于实践当中，开拓了视野，完善了知识结构。\n\n北京华清远见科技发展有限公司 Java EE 实训课\n本次实训由华清远见资深讲师向学员展示 JavaWeb-J2EE 企业级项目。涉及前端和后端研发，开发环境搭建、核心技术运用以及开发流程等满足企业真实岗位需求的实用内容和各种常用的配置及管理命令及 JavaWeb-J2EE 方向前端和后端开发的代码编写规范。\n\n华为“不负青春，码上行动”高校学生 DevCloud 实训课\n本次实训学习到了敏捷研发思想。由华为专家全程授课，届时将结合实际项目，使用先进的研发工具，模拟企业真实研发场景，从需求分析、项目规划、研发协同、代码检查、编译构建、部署、发布、测试等八个方面来帮助理解软件全生命周期。\n\n\n\n致谢感谢您花时间阅读我的简历，期待能有机会和您共事。\n\n","plink":"http://alpac.top/about/"},{"title":"相册","date":"2019-11-16T15:44:48.000Z","date_formatted":{"ll":"2019年11月16日","L":"2019/11/16","MM-DD":"11-16"},"updated":"2019-11-16T15:57:00.214Z","content":"\n","plink":"http://alpac.top/album/"}]