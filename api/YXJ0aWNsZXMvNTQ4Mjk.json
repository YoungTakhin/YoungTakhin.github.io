{"title":"设计模式3 单例模式","date":"2019-11-24T08:56:42.000Z","date_formatted":{"ll":"2019年11月24日","L":"2019/11/24","MM-DD":"11-24"},"color":"#EBF8FF","link":"articles/54829","comments":true,"tags":["设计模式"],"categories":["设计模式"],"updated":"2019-12-26T16:01:51.192Z","content":"<h1 id=\"设计模式3-单例模式\">设计模式3 单例模式<a href=\"articles/54829#设计模式3-单例模式\"></a></h1><p>单例模式(Singleton Pattern)是一种对象创建型模式。单例模式又名单件模式或单态模式。</p>\n<h2 id=\"单例模式定义\">单例模式定义<a href=\"articles/54829#单例模式定义\"></a></h2><ul>\n<li><p>单例模式：</p>\n<p>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>\n</li>\n<li><p>单例模式的要点：</p>\n<ul>\n<li>单例类只能有一个实例；</li>\n<li>单例类必须自己创建自己的唯一实例；</li>\n<li>单例类必须对外提供一个访问该实例的全局访问点。</li>\n</ul>\n</li>\n<li><p>单例模式优缺点：</p>\n<p>优点：</p>\n<ul>\n<li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li>\n<li>系统内存中只存在一个对象，节约系统资源，尤其适用一些需要频繁创建和销毁的对象，可以提高系统的性能。</li>\n<li>允许可变数目的实例。可基于单例模式进行扩展，使用与单例控制相似的方式来获得指定个数的对象实例。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li>\n<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li>\n<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"单例模式结构\">单例模式结构<a href=\"articles/54829#单例模式结构\"></a></h2><ul>\n<li><p>单例模式类图：</p>\n<p><img src=\"https://s2.ax1x.com/2019/11/26/QSKg00.png\" alt=\"单例模式类图\" class=\"article-img\"></p>\n</li>\n</ul>\n<h2 id=\"单例模式实现方式\">单例模式实现方式<a href=\"articles/54829#单例模式实现方式\"></a></h2><h3 id=\"懒汉式（线程不安全）\">懒汉式（线程不安全）<a href=\"articles/54829#懒汉式（线程不安全）\"></a></h3><p>  最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式懒加载很明显，不要求线程安全，在多线程不能正常工作。</p>\n  <figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"懒汉式（线程安全）\">懒汉式（线程安全）<a href=\"articles/54829#懒汉式（线程安全）\"></a></h3><p>  这种方式具备很好的懒加载，能够在多线程中很好的工作，但是效率很低，绝大多数情况下不需要同步。</p>\n  <figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"饿汉式\">饿汉式<a href=\"articles/54829#饿汉式\"></a></h3><p>  较常用的实现方式，但没有懒加载效果，容易产生垃圾对象。</p>\n  <figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"双检锁（DCL，即-double-checked-locking，双重校验锁）\">双检锁（DCL，即 double-checked locking，双重校验锁）<a href=\"articles/54829#双检锁（DCL，即-double-checked-locking，双重校验锁）\"></a></h3><p>  这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p>\n  <figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"登记式-静态内部类\">登记式/静态内部类<a href=\"articles/54829#登记式-静态内部类\"></a></h3><p>  这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用懒加载，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要懒加载时使用。</p>\n  <figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"枚举\">枚举<a href=\"articles/54829#枚举\"></a></h3><p>  枚举方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p>\n  <figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton &#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomeThing</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n\n<p>  <strong>注意</strong></p>\n<p>  枚举单例的优点就是简单，但大部分应用开发很少用枚举，可读性不高，不建议使用，上述几种实现方式中，反序列化将会会破坏单例模式，可以添加如下方法来防止单例对象被反序列化时重新生成对象：<br>  <figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">readResolve</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ObjectStreamException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure></p>\n<p>实现方式对比表：</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th>懒加载</th>\n<th>线程安全</th>\n<th>实现难度</th>\n<th>JDK版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>懒汉式（线程不安全）</strong></td>\n<td>是</td>\n<td>否</td>\n<td>易</td>\n<td>*</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>懒汉式（线程安全）</strong></td>\n<td>是</td>\n<td>是</td>\n<td>易</td>\n<td>*</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>饿汉式</strong></td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>*</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>双检锁</strong></td>\n<td>是</td>\n<td>是</td>\n<td>较难</td>\n<td>JDK1.5+</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>登记式</strong></td>\n<td>是</td>\n<td>是</td>\n<td>一般</td>\n<td>*</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>枚举</strong></td>\n<td>否</td>\n<td>是</td>\n<td>易</td>\n<td>JDK1.5+</td>\n</tr>\n</tbody></table></div></div>\n<p>一般情况下，不建议使用第 1、2 种懒汉式，建议使用第 3 种饿汉式。只有在要明确实现懒加载效果时，才会使用第 5 种登记式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>\n<h2 id=\"单例模式扩展\">单例模式扩展<a href=\"articles/54829#单例模式扩展\"></a></h2><p>单例模式可扩展为有限的多例（Multiton）模式，这种模式可生成有限个实例并保存在 ArrayList 中，用户需要时可随机获取。</p>\n<p><img src=\"https://s2.ax1x.com/2019/12/02/QndIu6.png\" alt=\"多例模式\" class=\"article-img\"></p>\n","prev":{"title":"设计模式4 原型模式","link":"articles/64779"},"next":{"title":"设计模式2 UML类图与时序图简介","link":"articles/48322"},"plink":"http://alpac.top/articles/54829/","toc":[{"title":"设计模式3 单例模式","id":"设计模式3-单例模式","index":"1","children":[{"title":"单例模式定义","id":"单例模式定义","index":"1.1"},{"title":"单例模式结构","id":"单例模式结构","index":"1.2"},{"title":"单例模式实现方式","id":"单例模式实现方式","index":"1.3","children":[{"title":"懒汉式（线程不安全）","id":"懒汉式（线程不安全）","index":"1.3.1"},{"title":"懒汉式（线程安全）","id":"懒汉式（线程安全）","index":"1.3.2"},{"title":"饿汉式","id":"饿汉式","index":"1.3.3"},{"title":"双检锁（DCL，即 double-checked locking，双重校验锁）","id":"双检锁（DCL，即-double-checked-locking，双重校验锁）","index":"1.3.4"},{"title":"登记式/静态内部类","id":"登记式-静态内部类","index":"1.3.5"},{"title":"枚举","id":"枚举","index":"1.3.6"}]},{"title":"单例模式扩展","id":"单例模式扩展","index":"1.4"}]}],"reward":true,"copyright":{"author":"Yang Dexuan","link":"<a href=\"http://alpac.top/articles/54829/\" title=\"设计模式3 单例模式\">http://alpac.top/articles/54829/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}